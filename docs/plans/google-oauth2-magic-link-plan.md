# Implementation Plan: Google OAuth2 Magic Link Per-User Auth

> Generated by `/PACT:plan-mode` on 2026-02-19
> Status: APPROVED

## Summary

Replace the existing service account (`GOOGLE_APPLICATION_CREDENTIALS`) authentication with per-user OAuth2. Each user connects their Google account once via a magic link delivered through the bot channel. All Gmail, Drive, and Calendar API calls then use the requesting user's own token. The Google Chat service account is preserved for bot operations. A lazy authorization pattern triggers the magic link automatically when a user invokes a Google-dependent skill without a connected account â€” no explicit "connect" command required. After authorization, the original command is auto-retried via an Oban `PendingIntentWorker` job (Postgres-backed, survives Railway restarts/deploys).

---

## Specialist Perspectives

### ðŸ“‹ Preparation Phase
**Effort**: Medium

#### Research Needed
- [x] Google OAuth2 web-server authorization code flow â€” standard, well-documented
- [x] Goth per-user refresh token support â€” confirmed: `{:refresh_token, %{client_id, client_secret, refresh_token}}` source works stateless (no running process needed)
- [x] `oauth2` hex package need â€” **not needed**; Req (already a dep) handles token exchange POST
- [x] Railway HTTPS/redirect URI â€” HTTPS auto-provided; `PHX_HOST` already in `runtime.exs`
- [x] OOB flow deprecation â€” confirmed deprecated; web redirect flow required
- [x] Cloak.Ecto encryption patterns â€” `Assistant.Vault` + `Assistant.Encrypted.Binary` already in place
- [ ] Google Cloud Console OAuth client setup â€” manual prerequisite (user action)

#### Dependencies to Map
- Goth `~> 1.4` â€” already installed, supports stateless refresh token source
- Req â€” already installed, handles token exchange HTTP POST
- Oban â€” already installed, handles async intent replay after OAuth
- Cloak.Ecto â€” already installed, encrypts token fields at rest
- `PHX_HOST` â€” already in `runtime.exs`; callback URI is `https://#{PHX_HOST}/auth/google/callback`

#### Questions to Resolve
- [x] Token exchange library â†’ **Req** (existing dep, simple HTTP POST)
- [x] Magic link state â†’ **DB table** (`auth_tokens`) for Railway restart safety
- [x] Per-user token strategy â†’ **Stateless Goth.Token.fetch/1** (no per-user GenServer processes)
- [x] Service account â†’ **Keep** for Google Chat bot scope only

---

### ðŸ—ï¸ Architecture Phase
**Effort**: Medium

#### Components Affected
| Component | Change Type | Impact |
|-----------|-------------|--------|
| `Assistant.Auth` (`auth.ex`) | Major rewrite | Split into `service_token/0` + `user_token/1` |
| `Assistant.Auth.OAuth` | New | Stateless token exchange, refresh, URL builder |
| `Assistant.Auth.MagicLink` | New | Generate, validate, consume magic link tokens |
| `Assistant.Auth.TokenStore` | New | Encrypted CRUD for `oauth_tokens` table |
| `AssistantWeb.OAuthController` | New | `/auth/google/start` + `/auth/google/callback` |
| `Assistant.Workers.ReplayIntentWorker` | New | Oban worker: auto-retry original command post-auth |
| `Assistant.Accounts.OAuthToken` | New | Ecto schema for `oauth_tokens` |
| `Orchestrator.Context` (or equivalent) | Modify | Lazy auth check before skill execution |
| `Google.Drive`, `Gmail`, `Calendar` | Modify | Accept `access_token` param from context |
| `Google.Chat` | Modify | Switch to `Auth.service_token/0` |
| `Assistant.Application` | Modify | Narrow Goth scope; no new supervised processes needed |
| `AssistantWeb.Router` | Modify | Add `/auth/google/*` scope |
| `config/runtime.exs` | Modify | Add `GOOGLE_OAUTH_CLIENT_ID`, `GOOGLE_OAUTH_CLIENT_SECRET` |

#### Design Approach

**Lazy authorization flow:**
```
User: "What's on my calendar tomorrow?"
    â†“
Orchestrator selects calendar.list skill
    â†“
Context.build/1 checks oauth_tokens for user_id + provider=google
    â†“ (no token found)
MagicLink.generate(user_id, pending_intent) â†’ magic link URL
    â†“
Bot sends: "I need to connect to your Google account to do that.
           Click here (expires in 10 min): [link]"
    â†“
User clicks â†’ /auth/google/start (validates magic link) â†’ redirect to Google consent
    â†“
Google redirects to /auth/google/callback?code=...&state=...
    â†“
Callback: validate state, exchange code, store encrypted tokens, enqueue ReplayIntentWorker
    â†“
Bot sends: "Connected as user@company.com. Resuming your request..."
    â†“
ReplayIntentWorker replays "What's on my calendar tomorrow?" through full pipeline
    â†“
Bot sends: calendar response
```

**Dual-mode auth:**
- `Auth.service_token/0` â†’ Goth service account (Chat bot operations)
- `Auth.user_token(user_id)` â†’ Stateless Goth.Token.fetch with refresh_token source from DB

#### Key Decisions
| Decision | Options | Recommendation | Rationale |
|----------|---------|----------------|-----------|
| Per-user token management | Per-user Goth process / Stateless Goth.Token.fetch / Raw HTTP | **Stateless Goth.Token.fetch** | Goth natively supports `{:refresh_token, ...}` source; stateless means zero process overhead; scales to any number of users |
| Magic link state storage | ETS / DB | **DB (`auth_tokens` table)** | Survives Railway restarts/deploys; ETS lost on any redeploy, unacceptable for 10-min links |
| Token table | Add fields to `users` / Separate `oauth_tokens` | **Separate `oauth_tokens`** | Future multi-provider support (HubSpot, Microsoft Graph); clean lifecycle separation |
| Lazy auth interception point | In each skill / In Auth module / In Context builder | **Context builder** | Single chokepoint; zero changes to skill modules; test engineer confirmed this preserves all existing ~50 skill tests |
| Pending intent storage | ETS / `auth_tokens.metadata` / Oban job args | **Oban `PendingIntentWorker` (parked state)** | Postgres-backed (survives Railway restarts); built-in TTL via `scheduled_at`; uniqueness constraint prevents duplicates; existing Oban infra in codebase |
| Token exchange | `oauth2` hex / Req | **Req** | Already a dependency; single HTTP POST is sufficient |
| Replay mechanism | Direct call / Oban | **Oban `PendingIntentWorker`** | OAuth callback parks job at far-future `scheduled_at`; callback reschedules to `now()` after tokens stored; follows `CompactionWorker`/`WorkflowWorker` patterns already in codebase |

#### Interface Contracts

```elixir
# Auth module â€” public interface
Auth.service_token() :: {:ok, String.t()} | {:error, term()}
Auth.user_token(user_id :: binary()) ::
  {:ok, String.t()} | {:error, :not_connected} | {:error, :refresh_failed}

# MagicLink â€” generates link AND parks Oban intent job atomically
Auth.MagicLink.generate(user_id, pending_intent) :: {:ok, url :: String.t()}
# pending_intent = %{message: str, conversation_id: uuid, channel: str, reply_context: map}
Auth.MagicLink.validate(token) ::
  {:ok, %{user_id: binary(), oban_job_id: integer()}} |
  {:error, :expired | :not_found | :already_used}

# Context builder return
Context.build(conversation) ::
  {:ok, %SkillContext{google_token: String.t() | nil}} |
  {:needs_auth, :google, magic_link_url :: String.t()}

# Google integration clients (after refactor)
Drive.list_files(access_token, opts)      # was: Drive.list_files(opts)
Gmail.list_messages(access_token, opts)   # was: Gmail.list_messages(opts)
Calendar.list_events(access_token, opts)  # was: Calendar.list_events(opts)
Chat.send_message(space_id, body)         # unchanged (uses service_token internally)

# PendingIntentWorker â€” Oban worker
# Parked at far-future scheduled_at when magic link generated
# Rescheduled to DateTime.utc_now() by OAuthController after tokens stored
# Performs: ensure_engine_started -> Engine.send_message -> channel reply
# TTL check: bail if inserted_at > 10 minutes ago (intent too stale)
# Unique: [fields: [:user_id], period: :infinity, states: [:scheduled]]
```

---

### ðŸ’» Code Phase
**Effort**: Medium-High

#### Files to Create
| File | Purpose |
|------|---------|
| `lib/assistant/auth/oauth.ex` | OAuth2 URL builder, code exchange, stateless token refresh via Goth |
| `lib/assistant/auth/magic_link.ex` | Generate/validate/consume magic link tokens (DB-backed) |
| `lib/assistant/auth/token_store.ex` | Encrypted CRUD for `oauth_tokens` table |
| `lib/assistant_web/controllers/oauth_controller.ex` | `/auth/google/start` + `/auth/google/callback` |
| `lib/assistant/workers/pending_intent_worker.ex` | Oban worker (`queue: :oauth_replay`): parked at far-future `scheduled_at`, rescheduled by OAuthController; replays original command through full pipeline |
| `lib/assistant/accounts/oauth_token.ex` | Ecto schema for `oauth_tokens` |
| `priv/repo/migrations/TIMESTAMP_create_oauth_tokens.exs` | OAuth token storage |
| `priv/repo/migrations/TIMESTAMP_create_auth_tokens.exs` | Magic link token storage |
| `test/support/fixtures/oauth_fixtures.ex` | Factory: users with/without tokens, magic links |
| `test/support/helpers/oauth_bypass_helpers.ex` | Bypass setup for Google token endpoint |

#### Files to Modify
| File | Changes |
|------|---------|
| `lib/assistant/integrations/google/auth.ex` | Major rewrite: `service_token/0` + `user_token/1`; remove Goth service account token path from user calls |
| `lib/assistant/integrations/google/drive.ex` | Accept `access_token` as first param in all public functions |
| `lib/assistant/integrations/google/gmail.ex` | Accept `access_token` as first param in all public functions |
| `lib/assistant/integrations/google/calendar.ex` | Accept `access_token` as first param in all public functions |
| `lib/assistant/integrations/google/chat.ex` | Switch internal token call to `Auth.service_token/0` |
| `lib/assistant/application.ex` | Narrow Goth to chat.bot scope only; remove per-user Goth paths |
| `lib/assistant_web/router.ex` | Add `scope "/auth/google"` with start + callback routes |
| `config/runtime.exs` | Add `GOOGLE_OAUTH_CLIENT_ID`, `GOOGLE_OAUTH_CLIENT_SECRET`; remove/deprecate `GOOGLE_APPLICATION_CREDENTIALS` user path |
| Orchestrator context builder | Add lazy auth check: if Google skill needed and no token â†’ generate magic link |
| ~5 Google skill files | Thread `context.user_id` through to integration module calls |

#### Implementation Sequence
1. DB migrations (`oauth_tokens` + `auth_tokens` tables + schemas)
2. `Auth.OAuth` + `Auth.TokenStore` (token exchange, refresh, storage)
3. `Auth.MagicLink` (generate, validate, consume â€” DB-backed)
4. `OAuthController` + router routes (full OAuth callback flow)
5. `Auth` module rewrite (`service_token/0` + `user_token/1`)
6. Orchestrator context builder lazy auth interception
7. Google integration client refactor (add `access_token` param to Drive/Gmail/Calendar)
8. Skill handler updates (thread `context.user_id`)
9. `ReplayIntentWorker` Oban job
10. Magic link delivery formatting per channel (Chat card, Telegram button, WhatsApp text)

Steps 1-3 can be parallelized. Step 4 depends on 2+3. Steps 5-8 depend on 2. Step 9 depends on 5+6.

---

### ðŸ§ª Test Phase
**Effort**: High (~70 tests)

**Risk Tier: CRITICAL** â€” touches auth, PII/credentials, per-user token isolation.

#### Test Scenarios
| Scenario | Type | Priority |
|----------|------|----------|
| Magic link generation: valid, unique, expiring tokens | Unit | P0 |
| OAuth callback happy path: code exchange + token storage | Integration (ConnCase + Bypass) | P0 |
| Expired magic link rejected | Unit + Integration | P0 |
| Already-used magic link rejected (replay attack) | Integration | P0 |
| State parameter CSRF validation | Integration (ConnCase) | P0 |
| Per-user token isolation (User A cannot use User B's token) | Integration (DataCase) | P0 |
| Token refresh on expired access token | Unit + Integration | P0 |
| Skill execution with valid per-user token | Unit | P0 |
| Skill execution with no token triggers magic link | Unit | P0 |
| Token encryption/decryption roundtrip | Unit | P0 |
| ReplayIntentWorker: replays original command after OAuth | Integration | P1 |
| Expired pending intent not replayed | Unit | P1 |
| Concurrent token refresh race condition | Integration | P1 |
| Token revocation detection (`invalid_grant`) | Unit | P1 |
| Multiple pending intents: latest wins | Unit | P2 |
| Post-auth notification delivered via channel | Unit | P2 |
| Cloak encryption key rotation (decryption still works) | Unit | P2 |

#### Coverage Targets
- Magic link gen/validation: 95%+
- OAuth callback controller: 90%+
- Token storage/retrieval: 90%+
- Token refresh logic: 90%+
- Modified Auth module: 85%+
- Modified Context builder: 80%+

#### Test Data Needs
- `OAuthFixtures.user_with_token/1` â€” user + valid oauth_tokens row
- `OAuthFixtures.user_without_token/1` â€” user with no oauth_tokens row
- `OAuthFixtures.expired_token/1` â€” user with expired access_token but valid refresh_token
- `OAuthFixtures.revoked_token/1` â€” user with invalid refresh_token
- `OAuthFixtures.magic_link/1` â€” valid auth_tokens row with pending_intent
- `OAuthFixtures.expired_magic_link/1` â€” auth_tokens row with past expires_at
- Bypass helper: stub `POST https://oauth2.googleapis.com/token` response

**Key test architecture note**: Resolve per-user tokens in the context builder (not at call sites). This preserves all ~50 existing Google skill tests which use module injection â€” they receive MockGmail/MockCalendar as before, no changes needed.

---

## Database Schema

### `oauth_tokens` table
```sql
CREATE TABLE oauth_tokens (
  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id          UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  provider         TEXT NOT NULL CHECK (provider IN ('google')),
  provider_uid     TEXT,                    -- Google 'sub' claim
  provider_email   TEXT,                    -- for display + first-connect confirmation
  refresh_token    BYTEA NOT NULL,          -- Cloak.Ecto encrypted
  access_token     BYTEA,                   -- Cloak.Ecto encrypted (defense in depth)
  token_expires_at TIMESTAMPTZ,
  scopes           TEXT,                    -- space-delimited
  inserted_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at       TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE (user_id, provider)
);
CREATE INDEX idx_oauth_tokens_user_provider ON oauth_tokens(user_id, provider);
```

### `auth_tokens` table
```sql
CREATE TABLE auth_tokens (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id         UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  token_hash      TEXT NOT NULL UNIQUE,     -- SHA-256 of raw token (never store raw)
  purpose         TEXT NOT NULL CHECK (purpose IN ('oauth_google')),
  oban_job_id     BIGINT,                   -- FK to oban_jobs.id (parked PendingIntentWorker job)
  expires_at      TIMESTAMPTZ NOT NULL,
  used_at         TIMESTAMPTZ,              -- NULL until consumed (single-use)
  inserted_at     TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX idx_auth_tokens_hash ON auth_tokens(token_hash);
CREATE INDEX idx_auth_tokens_expires ON auth_tokens(expires_at);
CREATE INDEX idx_auth_tokens_user_purpose_unused
  ON auth_tokens(user_id, purpose) WHERE used_at IS NULL;
```

Cleanup: Oban recurring job deletes `auth_tokens WHERE expires_at < NOW() - INTERVAL '24 hours'`. Parked `PendingIntentWorker` Oban jobs cancelled when magic link expires or is consumed (via `oban_job_id` reference).

---

## Security Requirements (Non-Negotiable)

All 10 of these **must** be implemented:

| # | Control |
|---|---------|
| 1 | Single-use magic link tokens â€” atomic DB consumption (`UPDATE ... WHERE used_at IS NULL RETURNING *`) |
| 2 | 10-minute TTL on magic links |
| 3 | 32-byte cryptographically random tokens (`:crypto.strong_rand_bytes/1`), SHA-256 hash stored in DB |
| 4 | CSRF-resistant state parameter â€” HMAC-signed payload binding `{user_id, channel, token_hash, timestamp}` |
| 5 | PKCE (S256) on all OAuth flows |
| 6 | Cloak.Ecto encryption for **both** `refresh_token` and `access_token`, and `pending_intent` |
| 7 | Google email validation on callback â€” store `provider_email` from ID token, confirm to user via post-auth notification |
| 8 | Re-validate authorization on intent replay â€” replay goes through full pipeline (rate limiting, sentinel, skill validation) |
| 9 | Rate limiting â€” max 3 magic links/hour/user |
| 10 | Post-authorization notification â€” confirm connected Google account to user via bot channel |

---

## Synthesized Implementation Roadmap

### Phase Sequence

```
[Manual prereq] GCP OAuth client setup â†’ get client_id + client_secret
        â†“
[PREPARE] Confirm env vars + Railway redirect URI config
        â†“
[CODE â€” parallel group 1]
  â”œâ”€â”€ oauth_tokens migration + OAuthToken schema
  â”œâ”€â”€ auth_tokens migration + AuthToken schema
  â””â”€â”€ Auth.OAuth module (token exchange + refresh via Goth stateless)
        â†“
[CODE â€” parallel group 2]
  â”œâ”€â”€ Auth.MagicLink (generate/validate/consume)
  â””â”€â”€ Auth.TokenStore (encrypted CRUD)
        â†“
[CODE] OAuthController + router routes
        â†“
[CODE â€” parallel group 3]
  â”œâ”€â”€ Auth module rewrite (service_token/0 + user_token/1)
  â”œâ”€â”€ Context builder lazy auth interception
  â””â”€â”€ Drive/Gmail/Calendar refactor (access_token param)
        â†“
[CODE] ReplayIntentWorker + skill handler user_id threading
        â†“
[CODE] Magic link delivery formatting per channel
        â†“
[TEST] Full test suite (~70 tests)
```

### Commit Sequence (Proposed)

1. `feat: add oauth_tokens and auth_tokens migrations and schemas` â€” DB layer foundation
2. `feat: add Auth.OAuth module for stateless token exchange and refresh` â€” token management
3. `feat: add Auth.MagicLink and Auth.TokenStore modules` â€” magic link lifecycle
4. `feat: add OAuthController and /auth/google routes` â€” full OAuth callback flow
5. `refactor: split Auth into service_token/0 and user_token/1` â€” auth module rewrite
6. `feat: add lazy auth interception to orchestrator context builder` â€” missing-token detection
7. `refactor: thread access_token through Drive, Gmail, Calendar clients` â€” integration refactor
8. `feat: add PendingIntentWorker Oban job for auto-retry after OAuth` â€” parks original intent, replays post-auth via full pipeline (rate limiting, sentinel, skill validation)
9. `feat: format magic link delivery per channel adapter` â€” UX polish
10. `test: add OAuth2 magic link test suite` â€” ~70 tests

---

## Cross-Cutting Concerns

| Concern | Status | Notes |
|---------|--------|-------|
| Security | Needs attention | 10 non-negotiable controls; see Security Requirements section |
| Performance | Ready | Stateless token refresh adds ~200ms once/hour on expiry; ETS cache can be added later if needed |
| Observability | Needs attention | Token refresh failures must be logged; magic link generation/consumption should emit telemetry |
| Migration | Needs attention | Existing `GOOGLE_APPLICATION_CREDENTIALS` â†’ deprecate; `GOOGLE_IMPERSONATE_EMAIL` â†’ see Open Questions |

---

## Open Questions

### Require User Decision

All decisions resolved:

- [x] **Remove `GOOGLE_IMPERSONATE_EMAIL`**: **Remove completely.** Per-user OAuth replaces all DWD needs.
- [x] **Multiple pending intents**: **Latest only.** When a new magic link is generated, invalidate any existing pending magic link for that user. Latest intent wins.
- [x] **First-time email validation**: **Accept any account, notify user.** Store `provider_email` from ID token on first connect, send confirmation message: "Connected as user@company.com".

### Require Further Research
- [ ] **Oban version compatibility**: Confirm `ReplayIntentWorker` pattern matches Oban version in `mix.exs`
- [ ] **Google OAuth consent screen**: Confirm whether app needs to go through Google verification for sensitive scopes (Gmail, Drive) or if test-user mode suffices

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Auth refactor breaks Chat bot | Med | High | Keep Goth service account; split auth paths clearly; test first |
| Existing ~50 skill tests break | High | Med | Resolve tokens in context builder upstream; keep module injection unchanged |
| Railway restart during 10-min OAuth window | Low | Med | DB-backed magic links survive restarts |
| Concurrent token refresh race | Low | Low | Goth.Token.fetch is idempotent; accept race for MVP |
| Google consent screen rejection (sensitive scopes) | Med | High | Test-user mode during dev; plan verification path |
| Token revocation mid-conversation | Low | Med | Detect `invalid_grant`, delete token, re-trigger magic link |
| Magic link forwarding (channel trust varies) | Med | Med | Single-use + 10-min TTL + email validation + post-auth notification |

---

## Scope Assessment

- **Overall Complexity**: High
- **Estimated Files**: 8 new, 10 modified
- **Specialists Required**: backend-coder, database-engineer, security-engineer, test-engineer
- **External Dependencies**: Google OAuth2 client (GCP Console setup required before coding)
- **Manual Prerequisites**: GCP Console â€” create OAuth 2.0 Client ID (Web Application), set redirect URI, configure consent screen scopes

---

## Phase Requirements

| Phase | Required? | Rationale |
|-------|-----------|-----------|
| PREPARE | No | All research complete; no TBD items remain. Prereq is GCP console setup (user action, not code) |
| ARCHITECT | No | All interface contracts defined; key decisions resolved above |
| CODE | Yes | Always required |
| TEST | Yes | CRITICAL risk tier; ~70 tests needed; concurrent refresh, isolation, CSRF scenarios |

---

## Environment Variables

New (add to `.env` and Railway):
```
GOOGLE_OAUTH_CLIENT_ID=your-client-id.apps.googleusercontent.com
GOOGLE_OAUTH_CLIENT_SECRET=your-client-secret
```

Remove (after migration complete):
```
GOOGLE_APPLICATION_CREDENTIALS  # service account JSON â€” no longer needed for user calls
GOOGLE_IMPERSONATE_EMAIL         # domain-wide delegation â€” see Open Questions
GOOGLE_CLOUD_PROJECT_NUMBER      # keep if Google Chat JWT verification still needed
```

---

## Next Steps

**Before implementation can begin (user action required)**:
1. Go to [Google Cloud Console](https://console.cloud.google.com/) â†’ APIs & Services â†’ Credentials
2. Create **OAuth 2.0 Client ID** (type: Web Application)
3. Add authorized redirect URI: `https://YOUR_RAILWAY_DOMAIN/auth/google/callback`
4. Add scopes on consent screen: Gmail, Drive, Calendar (+ openid, email, profile)
5. Copy `client_id` and `client_secret` to `.env`

**Then**:
```
/PACT:orchestrate Implement per-user Google OAuth2 with magic link authorization flow
```
