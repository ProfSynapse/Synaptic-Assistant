# Implementation Plan: Skills-First AI Assistant

> Generated by `/PACT:plan-mode` on 2026-02-17
> Status: PENDING APPROVAL

<!-- Status Lifecycle:
     PENDING APPROVAL -> APPROVED -> IN_PROGRESS -> IMPLEMENTED
                    \-> SUPERSEDED (if replaced by newer plan)
                    \-> BLOCKED (if unresolved conflicts)

     Transition Ownership:
     - PENDING APPROVAL -> APPROVED: User (explicit approval)
     - APPROVED -> IN_PROGRESS: Orchestrator (when /PACT:orchestrate starts)
     - IN_PROGRESS -> IMPLEMENTED: Orchestrator (after successful completion)
     - Any -> SUPERSEDED: plan-mode (when creating replacement plan)
     - Any -> BLOCKED: plan-mode (when unresolved blocking conflicts)
-->

<!-- Forward Reference Convention:
     When deferring work to a later phase, use the standardized format:
     "Handled during {PHASE_NAME}" (e.g., "Handled during PREPARE")
-->

## Summary

A headless, **CLI-first multi-agent AI assistant** built in **Elixir/Phoenix** on the BEAM VM, hosted on **Railway**. The assistant receives messages from multiple channels (Google Chat, Telegram, WhatsApp, voice), routes them through an **orchestrator LLM** via **OpenRouter** that decomposes tasks and dispatches **sub-agents** to execute skills. The LLM interacts via **CLI commands** using **dot notation** (`email.send --to bob`, `tasks.search --status overdue`) — one tool call with one string parameter, parsed server-side. Skills are defined as **markdown files with minimal YAML frontmatter** (name + description only). The assistant can compose existing skills into **workflows** — repeatable multi-skill sequences (daily digest, weekly report). Progressive skill discovery via `get_skill` with **SKILL.md domain indexes** and `.all` suffix. The orchestrator can **directly invoke read-only skills** (`*.search`, `*.get`, `*.list`, `*.read`) for speed; only mutating skills require sub-agent delegation. Sub-agents receive scoped context and execute skills independently in serial/parallel based on a dependency DAG. Memory uses **PostgreSQL hybrid retrieval (FTS + pgvector + structured filters)**. Continuous conversation compaction maintains context across turns using a small cheap model. All managed content (Drive-backed normalized files + skill files) is indexed in PostgreSQL FTS for grep-like search.

---

## Key Decisions (Resolved During Planning)

| Decision | Choice | Rationale |
|----------|--------|-----------|
| **Language** | Elixir/Phoenix on BEAM VM | BEAM concurrency (GenServers, supervisors, "let it crash"), built-in scheduling, perfect for multi-integration multi-agent assistant. User preference. |
| **Sandbox** | None (in-process skills) | Skills are API wrappers + file manipulation. No sandbox eliminates cost, cold start latency, credential complexity. MuonTrap for CLI isolation. Future-proofed via `isolation_level` field. |
| **Database** | PostgreSQL + pgvector | Railway native Postgres. Ecto ORM. Hybrid retrieval (FTS + vectors + structured filters) for memory/content search. |
| **Memory search** | Hybrid (FTS + pgvector + filters) | PostgreSQL tsvector/tsquery + vector similarity + tags/metadata filters for robust keyword + semantic recall. |
| **Orchestration** | Multi-agent (orchestrator + sub-agents) | Orchestrator plans and coordinates via JSON tool-calling (dispatch_agent, get_agent_results). Sub-agents execute skills via CLI commands. Context isolation prevents pollution. |
| **CLI-first interface** | One tool, one string param | LLM outputs CLI commands in ```cmd blocks. Single `run` tool with `command` string parameter. Parsed server-side. Massive token savings vs JSON schemas. |
| **Dot notation naming** | `domain.action` format | `email.send`, `tasks.search`, `memory.save`. Maps directly to file paths (`skills/email/send.md`). Progressive discovery via `get_skill`. |
| **Skill definition** | Markdown + YAML frontmatter | Skills defined as `.md` files. YAML frontmatter: `name`, `description`, `confirm` (boolean, default based on action type). Markdown body = man-page style usage docs. Hot-reloadable via FileSystem watcher. |
| **SKILL.md domain indexes** | Per-domain index files | Each domain directory has a `SKILL.md` listing all commands. Progressive disclosure: `get_skill` → domains, `get_skill: email` → SKILL.md, `get_skill: email.send` → specific skill, `get_skill: email.all` → all skills. |
| **Workflow builder** | Compose skills into workflows | `workflow.build` meta-skill creates workflow markdown files. Skills are static tools; workflows compose them for repeatable tasks (daily digest, weekly report). Stored in `workflows/` directory. |
| **Orchestrator read access** | Direct read-only skill execution | Orchestrator can directly invoke `*.search`, `*.get`, `*.list`, `*.read` skills for speed. Only mutating skills (`*.create`, `*.update`, `*.delete`, `*.send`) require sub-agent delegation. |
| **Compaction** | Continuous (every turn) + topic-based memory extraction | Running summary: `summary(n) = LLM(summary(n-1), turn(n))` every turn (cheap model, 500 tokens, Oban async). Background memory agent detects topic shifts and extracts completed segments into searchable memory entries. Single continuous conversation model (no "conversation ends" event). |
| **Skill protocol** | Elixir behaviours + markdown files | Built-in skills = Elixir modules with `execute(flags, context)` callback. User-created skills = markdown files with YAML frontmatter. Both in same registry, same CLI interface. |
| **Managed content search** | PostgreSQL FTS index | All normalized Drive-backed content + skill files indexed in `content_index` table with weighted tsvector. Grep-like search capability. |
| **Voice** | OpenRouter STT + ElevenLabs TTS | OpenRouter for speech-to-text (audio via chat completions). ElevenLabs for text-to-speech (behind TTSClient behaviour). Phase 4. |
| **File operations** | Non-destructive versioning | Pull -> Manipulate -> Archive -> Replace. Never delete. Full audit trail. |
| **Error handling** | Circuit breakers + active alerting | Four-level limit hierarchy. OTP supervisors. Alerts to Google Chat/email with dedup. |
| **Prompt caching** | Cache-friendly message ordering | Static sections (system prompt + 2 tool defs) first → cache breakpoint. Alphabetical skill sorting for consistent tool definitions. Sub-agents with same skill sets share cache. |
| **Scheduling** | Quantum + Oban | Quantum for cron triggers, Oban for reliable Postgres-backed job queue with retries. |
| **Prompt injection defense** | Sentinel LLM + skill scoping + data boundaries | Three-layer defense: (1) `confirm` field on skills — read-only skills skip all checks; (2) Sentinel LLM (cheap model, context-isolated) returns `{"reasoning": "...", "decision": bool}` — sees only original request + mission + proposed action; (3) If `decision: false`, surface to user. Reasoning logged for audit. |
| **Workflow execution** | Agentic (sub-agent with workflow.md as mission) | Workflows are not rigid scripts. Orchestrator spawns a sub-agent with the workflow.md as instructions and scoped skills. Agent executes adaptively — retries on failure, works around issues, escalates to orchestrator if stuck. |
| **Memory extraction** | Topic-shift detection in compaction model | Compaction model returns `topic_changed: boolean` each turn. If true, same call extracts memory entry (tags, importance, summary). No separate agent — one model call, one prompt. |
| **Model roster** | Curated list with orchestrator selection | Configured model list with tier/description. Orchestrator picks model per sub-agent dispatch based on task complexity. Default: orchestrator's own model. Config-only changes (no code). |
| **TTS fallback** | Retry + notify | Retry once with backoff, then text fallback with notification when voice input detected. |
| **Entity graph** | Phase 1 (define now) | `memory_entity`, `memory_entity_relation`, `memory_entity_mention` tables included in initial schema. Enables "show me everything related to X" queries. |

---

## Specialist Perspectives

### Preparation Phase
**Effort**: Medium

#### Research Needed
- [x] Language evaluation: Elixir vs TypeScript vs Python (resolved: Elixir)
- [x] Sandbox evaluation: E2B vs alternatives vs none (resolved: no sandbox)
- [x] Database evaluation: Postgres vs SQLite (resolved: Postgres)
- [x] Memory search: pgvector vs FTS (resolved: FTS + tags + filters, pgvector deferred)
- [x] Voice providers: STT + TTS selection (resolved: OpenRouter STT + ElevenLabs TTS)
- [ ] Elixir ecosystem audit: Verify maturity of Telegex, whatsapp_elixir, google_api_drive, goth
- [ ] OpenRouter API: Document tool-calling format, streaming protocol, model fallback, prompt caching (cache_control breakpoints)
- [ ] Google OAuth2 flow: Service account + domain-wide delegation setup for Drive/Gmail/Calendar
- [ ] WhatsApp Business API: Evaluate if whatsapp_elixir exists or if HTTP wrapper needed
- [ ] HubSpot API: Evaluate hubspotex maturity or plan HTTP wrapper
- [ ] ElevenLabs API: Document TTS endpoints, streaming audio, voice selection, latency
- [ ] OpenRouter STT: Document audio input format via chat completions API
- [ ] MCP protocol: Study spec (2025-11-25) for skill interface inspiration
- [ ] Railway deployment: Elixir/Phoenix release configuration, health checks, Postgres provisioning
- [ ] Elixir best practices: Coding conventions, OTP patterns, testing patterns (in progress — task #12)

#### Questions Resolved
- [x] Google API authentication: **Service account with domain-wide delegation**
- [x] Managed content access: **Google Drive API** — Drive is the backing store for synced content
- [x] First channel: **Google Chat** — already in workspace
- [x] Orchestration pattern: **Multi-agent** — orchestrator delegates to sub-agents
- [x] Tool surface: **Two meta-tools** — get_skill + dispatch_agent (+ get_agent_results)

#### Questions to Resolve
- [ ] Voice latency budget: Acceptable round-trip for voice interactions?

---

### Architecture Phase
**Effort**: High

#### Components

| Component | Type | Purpose |
|-----------|------|---------|
| **Message Gateway** | Phoenix endpoint + GenServer adapters | Receive webhooks, normalize to common format |
| **Channel Adapters** | GenServer per channel type | Telegram, Google Chat, WhatsApp, Voice — `ChannelAdapter` behaviour |
| **Orchestrator Engine** | GenServer per conversation | Manages orchestrator LLM calls, sub-agent dispatch, DAG execution |
| **Sub-Agent Executor** | Task.Supervisor per conversation | Execute sub-agents as supervised async tasks with scoped context |
| **Skill Registry** | ETS table + module discovery | Discover, register, look up skills. Domain/name/search queries for meta-tools |
| **Skill Executor** | Task.Supervisor | Execute individual skills within sub-agents with timeouts |
| **Meta-Tools** | Modules (GetSkill, DispatchAgent, GetAgentResults) | Orchestrator's JSON tool interface — discovery + delegation |
| **CLI Parser** | Module | Tokenize CLI command strings, resolve command+subcommand, validate flags against YAML schema |
| **CLI Extractor** | Module | Detect ```cmd fenced blocks in LLM output, separate commands from text |
| **Content Index** | PostgreSQL table + Oban worker | FTS index of normalized managed content + skill files for grep-like search |
| **Workflow Builder** | Meta-skill (`workflow.build`) | Assistant composes existing skills into workflow markdown files at runtime |
| **FileSystem Watcher** | GenServer | Detect skill file changes, trigger registry hot-reload |
| **Circuit Breakers** | GenServer + `:fuse` | Four-level: per-skill (30s), per-agent (5 calls), per-turn (8 agents / 30 calls), per-conversation (50/5min) |
| **Memory System** | FTS + tags + structured filters | Conversation history, memory entries, entity graph, context assembly |
| **Sentinel** | Module (cheap LLM call) | Context-isolated security gate for irreversible actions. Sees only: original request + agent mission + proposed action. Returns JSON `{"reasoning": "...", "decision": true/false}` — reasoning first (chain of thought), then boolean. If `false`, surface to user. |
| **Compaction Engine** | Oban worker + topic detection | Continuous incremental summary after each turn. Returns `topic_changed` boolean; if true, extracts memory entry (tags, importance) in same call. |
| **Task Manager** | Skills (CRUD) + 4-table schema | Task tracking exposed as skills the LLM invokes via CLI commands (tasks.create, tasks.search, etc.) |
| **File Version Manager** | GenServer | PULL -> MANIPULATE -> ARCHIVE -> REPLACE workflow |
| **Integration Clients** | Modules per service | Google (Drive, Gmail, Calendar), HubSpot, OpenRouter (LLM + STT), ElevenLabs (TTS) |
| **Alert Router** | GenServer | Route errors to Google Chat webhooks / email with dedup + throttling |
| **Scheduler** | Quantum + Oban | Cron triggers + reliable Postgres-backed job queue |

#### System Architecture

```
                    Telegram  Google Chat  WhatsApp  Voice (OpenRouter STT + ElevenLabs TTS)
                       |          |          |          |
                       v          v          v          v
                  +------------------------------------------+
                  |        Message Gateway (Phoenix)         |
                  |   Channel Adapters (GenServer each)      |
                  +------------------------------------------+
                                    |
                          Normalized Message
                                    |
                                    v
                  +------------------------------------------+
                  |    Orchestrator Engine (GenServer)        |
                  |                                          |
                  |  1. Load context: summary + memory + history
                  |  2. Call OpenRouter (3 JSON tools:        |
                  |     get_skill, dispatch_agent,            |
                  |     get_agent_results)                    |
                  |  3. Orchestrator plans, decomposes task   |
                  |  4. Read-only skills: execute directly    |
                  |  5. Mutating skills: dispatch sub-agents  |
                  |  6. Collect results, synthesize response  |
                  |                                          |
                  |  Circuit Breakers | Agent Limits          |
                  +------------------------------------------+
                      |           |                    |
              Direct read    Sub-Agent Executor   Memory System
              (*.search,     (Task.Supervisor)   (FTS + tags)
               *.get, etc.)       |                    |
                      |   +-------+-------+    Compaction Engine
                      |   |       |       |    (Oban, small model)
                      | Agent 1 Agent 2 Agent 3
                      | (email)  (tasks) (calendar)
                      |   |       |       |
                      v   v       v       v
                   Skill Executor (CLI commands)
                      |       |       |
                  Gmail API PostgreSQL Calendar API
                          |
                  Task Manager (4 tables)
                  Memory Manager (entity graph)
                          |
                     PostgreSQL
                  (Ecto, FTS, tags)
```

#### Orchestrator Tool Surface (Hybrid: JSON + CLI)

The **orchestrator** uses JSON tool-calling for agent coordination:

| Tool | Purpose |
|------|---------|
| `get_skill` | Discover available skills. Returns CLI help text (not JSON schemas). |
| `dispatch_agent` | Spawn sub-agent with mission, scoped command list, depends_on for serial execution. |
| `get_agent_results` | Collect results from dispatched sub-agents (blocks until complete/timeout). |

**Sub-agents** use CLI commands for skill execution:

| Mechanism | Purpose |
|-----------|---------|
| `run` tool (1 param: `command` string) | Execute a CLI command. e.g., `email send --to bob --subject "Q1"` |

Sub-agents output CLI commands in ```cmd fenced blocks using dot notation (e.g., `email.send --to bob`). The system extracts, parses, validates against skill definition, and executes.

**Progressive disclosure example** (what `get_skill` returns at each level):

`get_skill` → all domains:
```
Available skill domains:
  email       Email management (send, search, read, draft)
  tasks       Task tracking (create, search, get, update, delete)
  calendar    Calendar management (create, list, update)
  memory      Long-term memory (save, search)
  files       Unified content/storage (search, read, write, move, sync)
  hubspot     CRM (contacts, deals, notes)
  workflows   User-created workflows (daily_digest, weekly_report)

Use: get_skill: {domain} for commands
```

`get_skill: email` → SKILL.md domain index:
```
# email — Email Management
  email.send     Send an email
  email.search   Search emails
  email.read     Read an email by ID
  email.draft    Save a draft email
```

`get_skill: email.send` → specific skill man page

#### Skill Interface

**Built-in skills** (Elixir behaviour):
```elixir
defmodule Assistant.Skills.Handler do
  @callback execute(flags :: map(), context :: SkillContext.t()) :: {:ok, String.t()} | {:error, term()}
end
```

**Workflows** (compositions of existing skills, created via `workflow.build`):
```markdown
---
name: workflows.daily_digest
description: "8am digest of emails, calendar, and transcripts"
schedule: "0 8 * * *"
---

# workflows.daily_digest

Compile a morning briefing from unread emails and today's calendar.

## Usage
workflows.daily_digest [--lookback-hours=24]

## Flags
--lookback-hours  Hours to look back (default: 24)

## Behavior
1. email.search --after {lookback} --unread
2. calendar.list --date today
3. Synthesize into briefing
4. Send to Google Chat
```

Both built-in skills and workflows register in the same CLI-based registry. The LLM discovers and uses them identically:
```
workflows.daily_digest --lookback-hours=48
```

**Everything is a CLI command** — the LLM discovers and uses memory, tasks, email, calendar, etc. through the same interface:

| Domain | Skills | Notes |
|--------|--------|-------|
| `email` | email.send, email.read, email.search, email.draft | Gmail API via service account |
| `calendar` | calendar.create, calendar.list, calendar.update | Google Calendar API |
| `files` | files.search, files.read, files.write, files.move, files.sync | Unified content/storage over Drive-backed synced workspace |
| `hubspot` | hubspot.contacts, hubspot.deals, hubspot.notes | HubSpot CRM API |
| `tasks` | tasks.create, tasks.search, tasks.get, tasks.update, tasks.delete | PostgreSQL-backed task management |
| `memory` | memory.save, memory.search | Hybrid retrieval (FTS + pgvector + filters) |
| `workflow` | workflow.build | Meta-skill for creating workflows |
| `workflows` | workflows.daily_digest, workflows.weekly_report, ... | Agentic workflows — sub-agent gets workflow.md as mission + scoped skills, executes adaptively |

#### Key Design Decisions

| Decision | Options | Choice | Rationale |
|----------|---------|--------|-----------|
| Orchestration pattern | Single LLM loop / Multi-agent | Multi-agent | Context isolation, parallelism, scoped tools, independent failure |
| Sub-agent lifecycle | Long-lived / Ephemeral | Ephemeral | Fresh context per task, no state leakage, clean isolation |
| DAG execution | Sequential only / Parallel only / DAG | DAG with `depends_on` | Maximum flexibility: serial when needed, parallel by default |
| Sub-agent model | Same as orchestrator / Cheaper / Curated roster | Curated model roster | Configured list of models with tier/description. Orchestrator selects per dispatch. Default: orchestrator's model. Config-only changes. |
| Skill execution | Direct in orchestrator / Via sub-agents only / Hybrid | Hybrid (read-only direct, mutating via sub-agents) | Orchestrator directly invokes read-only skills (*.search, *.get, *.list, *.read) for speed. Mutating skills (*.create, *.update, *.delete, *.send) require sub-agent delegation. |
| Memory search | pgvector / FTS + filters | FTS + tags + filters | Simpler, no embedding cost, additive path to vectors later |
| Compaction | On context limit / Continuous | Continuous per turn | Always-fresh summary, no cliff edge when hitting limit |
| Prompt caching | Ad-hoc / Structured | Cache-friendly prefix ordering | Static system prompt + tool defs cached. ~3,600 token savings/turn. |

#### Interface Contracts

**Normalized Message Format**:
```elixir
%ConversationMessage{
  id: "msg_xxx",
  channel: :telegram | :google_chat | :whatsapp | :voice,
  channel_message_id: "platform_specific_id",
  user_id: "user_xxx",
  content: "text content",
  attachments: [%Attachment{type: :file | :image | :audio, url: "..."}],
  metadata: %{},
  timestamp: ~U[2026-02-17 10:30:00Z]
}
```

**Skill Result Format**:
```elixir
%SkillResult{
  status: :ok | :error,
  content: "text result for LLM",
  files_produced: [%{path: "...", name: "...", mime_type: "..."}],
  side_effects: [:file_updated, :email_sent, :event_created],
  metadata: %{}
}
```

---

### Code Phase
**Effort**: High

#### Project Structure

```
assistant/
├── config/
│   ├── config.exs              # Base configuration
│   ├── dev.exs                 # Dev environment
│   ├── prod.exs                # Production
│   ├── runtime.exs             # Runtime config (env vars)
│   └── test.exs                # Test environment
│
├── lib/
│   ├── assistant/
│   │   ├── application.ex      # OTP Application, supervision tree
│   │   ├── repo.ex             # Ecto Repo
│   │   │
│   │   ├── channels/           # Message Gateway
│   │   │   ├── adapter.ex      # ChannelAdapter behaviour
│   │   │   ├── telegram.ex     # Telegram adapter (GenServer)
│   │   │   ├── google_chat.ex  # Google Chat adapter
│   │   │   ├── whatsapp.ex     # WhatsApp adapter
│   │   │   ├── voice.ex        # Voice adapter (OpenRouter STT + ElevenLabs TTS)
│   │   │   └── message.ex      # ConversationMessage struct
│   │   │
│   │   ├── orchestrator/       # Multi-Agent Orchestration
│   │   │   ├── engine.ex       # Orchestrator GenServer (per conversation)
│   │   │   ├── agent_scheduler.ex  # DAG dependency resolution, wave execution
│   │   │   ├── sub_agent.ex    # Sub-agent LLM call runner
│   │   │   ├── context.ex      # Context assembly (orchestrator + sub-agent)
│   │   │   ├── limits.ex       # Four-level circuit breaker hierarchy
│   │   │   ├── cli_parser.ex   # Tokenize + validate CLI commands against YAML schema
│   │   │   ├── cli_extractor.ex # Extract ```cmd blocks from LLM output
│   │   │   ├── sentinel.ex     # Context-isolated security classifier for irreversible actions
│   │   │   ├── loop_runner.ex  # Pure-function agent loop logic (extracted from engine.ex)
│   │   │   └── tools/          # Orchestrator meta-tools (JSON)
│   │   │       ├── get_skill.ex      # Skill discovery (returns CLI help text)
│   │   │       ├── dispatch_agent.ex # Sub-agent dispatch
│   │   │       └── get_agent_results.ex # Result collection
│   │   │
│   │   ├── skills/             # Skill System
│   │   │   ├── handler.ex      # Handler behaviour (execute/2 callback)
│   │   │   ├── registry.ex     # ETS registry keyed by {command, subcommand}
│   │   │   ├── loader.ex       # Load + validate YAML frontmatter from .md files
│   │   │   ├── workflow/        # Workflow builder
│   │   │   │   └── build.ex    # workflow.build meta-skill (compose skills into workflows)
│   │   │   ├── watcher.ex      # FileSystem watcher for hot-reload
│   │   │   ├── executor.ex     # Task.Supervisor-based execution
│   │   │   ├── result.ex       # SkillResult struct
│   │   │   ├── context.ex      # SkillContext (injected deps)
│   │   │   │
│   │   │   ├── email/          # Email domain skills
│   │   │   │   ├── send.ex
│   │   │   │   ├── read.ex
│   │   │   │   └── search.ex
│   │   │   ├── calendar/       # Calendar domain skills
│   │   │   │   ├── create.ex
│   │   │   │   ├── list.ex
│   │   │   │   └── update.ex
│   │   │   ├── files/          # Unified content/storage domain skills
│   │   │   │   ├── read.ex
│   │   │   │   ├── write.ex
│   │   │   │   ├── search.ex
│   │   │   │   ├── move.ex
│   │   │   │   └── sync.ex
│   │   │   ├── hubspot/        # HubSpot CRM domain skills
│   │   │   │   ├── contacts.ex
│   │   │   │   ├── deals.ex
│   │   │   │   └── notes.ex
│   │   │   ├── tasks/          # Task management domain skills
│   │   │   │   ├── create.ex
│   │   │   │   ├── search.ex
│   │   │   │   ├── get.ex
│   │   │   │   ├── update.ex
│   │   │   │   └── delete.ex
│   │   │   └── memory/         # Memory domain skills
│   │   │       ├── search.ex
│   │   │       ├── save.ex
│   │   │       └── entities.ex
│   │   │
│   │   ├── files/              # File Versioning System
│   │   │   ├── version_manager.ex
│   │   │   ├── workspace.ex
│   │   │   └── version.ex
│   │   │
│   │   ├── memory/             # Memory System (backend)
│   │   │   ├── store.ex        # Conversation persistence
│   │   │   ├── search.ex       # FTS + tags + structured filter queries
│   │   │   ├── context_builder.ex  # Context assembly for LLM calls
│   │   │   ├── extraction.ex   # Memory extraction pipeline (Oban worker)
│   │   │   ├── compaction.ex   # Continuous compaction (Oban worker, small model)
│   │   │   ├── lifecycle.ex    # Importance decay + pruning (Oban scheduled)
│   │   │   └── entry.ex        # MemoryEntry schema
│   │   │
│   │   ├── task_manager/       # Task Management (backend)
│   │   │   ├── task.ex         # Task schema
│   │   │   ├── dependency.ex   # TaskDependency schema
│   │   │   ├── comment.ex      # TaskComment schema
│   │   │   ├── history.ex      # TaskHistory schema (audit trail)
│   │   │   └── queries.ex      # Task search + filter queries
│   │   │
│   │   ├── resilience/         # Fault Tolerance
│   │   │   ├── circuit_breaker.ex
│   │   │   └── rate_limiter.ex
│   │   │
│   │   ├── notifications/      # Error Alerting
│   │   │   ├── router.ex
│   │   │   ├── google_chat.ex
│   │   │   └── email.ex
│   │   │
│   │   ├── integrations/       # External Service Clients
│   │   │   ├── google/
│   │   │   │   ├── auth.ex     # Service account (goth)
│   │   │   │   ├── drive.ex
│   │   │   │   ├── gmail.ex
│   │   │   │   └── calendar.ex
│   │   │   ├── hubspot.ex
│   │   │   ├── openrouter.ex   # LLM + STT client
│   │   │   └── elevenlabs.ex   # TTS client (behind TTSClient behaviour)
│   │   │
│   │   ├── scheduler/          # Cron & Job System
│   │   │   ├── cron.ex         # Quantum scheduler config
│   │   │   └── workers/        # Oban worker definitions
│   │   │       ├── compaction_worker.ex
│   │   │       ├── memory_extraction_worker.ex
│   │   │       ├── memory_lifecycle_worker.ex
│   │   │       └── notification_worker.ex
│   │   │
│   │   └── schemas/            # Shared Ecto Schemas
│   │       ├── conversation.ex # + summary, summary_version, summary_model
│   │       ├── message.ex      # + role enum (user/assistant/system/tool_call/tool_result)
│   │       ├── memory_entry.ex # + tags TEXT[], search_text tsvector
│   │       ├── memory_entity.ex
│   │       ├── memory_entity_relation.ex
│   │       ├── memory_entity_mention.ex
│   │       ├── skill_config.ex
│   │       ├── execution_log.ex # + parent_execution_id for sub-agent traces
│   │       ├── file_version.ex
│   │       ├── file_operation_log.ex
│   │       ├── notification_channel.ex
│   │       ├── notification_rule.ex
│   │       ├── scheduled_task.ex
│   │       └── user.ex
│   │
│   └── assistant_web/          # Phoenix (webhooks only)
│       ├── router.ex
│       ├── controllers/
│       │   ├── telegram_controller.ex
│       │   ├── google_chat_controller.ex
│       │   ├── whatsapp_controller.ex
│       │   └── health_controller.ex
│       └── plugs/
│           ├── webhook_verification.ex
│           └── rate_limit.ex
│
├── priv/repo/migrations/
├── test/
│   ├── support/ (fixtures, mocks, helpers)
│   ├── assistant/ (unit + integration tests mirror lib/)
│   └── assistant_web/ (controller tests)
│
├── mix.exs
├── Dockerfile
├── .formatter.exs
└── .env.example
```

#### Key Dependencies (mix.exs)

| Package | Purpose |
|---------|---------|
| `phoenix` | Web framework (webhook endpoints) |
| `ecto_sql` + `postgrex` | PostgreSQL ORM |
| `req` | HTTP client (all API integrations) |
| `goth` | Google OAuth2 service account auth |
| `google_api_drive` / `google_api_gmail` / `google_api_calendar` | Google API clients |
| `telegex` | Telegram Bot API |
| `jason` | JSON encoding/decoding |
| `quantum` | Cron scheduling |
| `oban` | Reliable Postgres-backed job processing |
| `cloak_ecto` | Transparent field encryption |
| `earmark` | Markdown parsing (AST manipulation) |
| `briefly` | Temp directory management with auto-cleanup |
| `muontrap` | OS process isolation with cgroups |
| `fuse` | Circuit breaker library |
| `mox` | Behaviour-based test mocking |
| `stream_data` | Property-based testing |
| `bypass` | HTTP mocking in tests |
| `credo` | Code quality |
| `dialyxir` | Static type analysis |
| `excoveralls` | Test coverage |

#### Implementation Sequence

1. Project scaffold (mix phx.new, Ecto setup, Postgres on Railway)
2. Core schemas + migrations (conversations, messages, memory, tasks, users)
3. Skill behaviour + registry + executor with timeouts
4. OpenRouter LLM client (chat completions + tool-calling + streaming + prompt caching)
5. Three meta-tools: get_skill + dispatch_agent + get_agent_results
6. Orchestration engine with hybrid skill access (read-only direct, mutating via sub-agents)
7. Sub-agent architecture: DAG scheduler, scoped context, CLI command execution
8. Circuit breaker system (four-level hierarchy)
9. Google Chat channel adapter (first channel — webhook + bot responses)
10. Google Drive integration + file versioning (service account + goth)
11. Memory system (FTS + tags + structured filters + context assembly)
12. Continuous compaction engine (Oban worker, small model)
13. Task management system (4-table schema + 5 skills)
14. Memory skills (memory.save, memory.search)
15. Notification/alerting system
16. Remaining domain skills (email, calendar, HubSpot, files advanced operations)
17. Scheduler (Quantum cron + Oban workers)
18. Telegram channel adapter
19. Voice pipeline (OpenRouter STT + ElevenLabs TTS)
20. WhatsApp channel adapter
21. Railway deployment config

---

### Test Phase
**Effort**: High

#### Test Pyramid

```
                    /\
                   /  \     E2E: Full conversation flows (5%)
                  /    \    Multi-turn, multi-agent through channels
                 /------\
                /        \  Contract/Integration (20%)
               /          \ API contracts, channel adapters, DB, sub-agents
              /--------------\
             /                \ Behavioural Unit Tests (35%)
            /                  \ Skill dispatch, prompt templates, DAG execution
           /--------------------\
          /                      \ Deterministic Unit Tests (40%)
         /                        \ Parsing, validation, transforms, FTS queries
        /____________________________\
```

#### Critical Test Scenarios

| Scenario | Type | Priority |
|----------|------|----------|
| Sub-agent DAG executes serial/parallel correctly | Unit | P0 |
| Orchestrator only directly invokes read-only skills (not mutating) | Unit | P0 |
| Circuit breaker opens after N failures (all 4 levels) | Unit | P0 |
| File versioning: archive before replace (invariant) | Unit + Integration | P0 |
| Prompt injection doesn't become tool call | Unit | P0 |
| Webhook signature validation | Unit | P0 |
| Sub-agent failure doesn't crash orchestrator | Integration | P0 |
| Continuous compaction produces valid summaries | Integration | P1 |
| Skill execution timeout enforcement | Unit | P1 |
| Notification dedup prevents alert storms | Unit | P1 |
| Context assembly stays within token budget | Unit | P1 |
| FTS + tags memory retrieval relevance | Integration | P1 |
| Task CRUD + search through skill interface | Integration | P1 |
| Prompt caching: stable prefixes produce cache hits | Integration | P2 |
| Voice pipeline round-trip latency | E2E | P2 |

#### Invariant Tests (run on every PR)

```
INVARIANT 1: No file is ever permanently deleted by the system
INVARIANT 2: Archive-before-replace ordering is never violated
INVARIANT 3: Orchestrator loop always terminates within configured limit
INVARIANT 4: Sub-agent tool calls are restricted to assigned skills
INVARIANT 5: Credentials never appear in logs or error notifications
INVARIANT 6: Webhook payloads are signature-verified before processing
INVARIANT 7: Compaction summary never exceeds token budget
```

#### CI/CD Pipeline

```
Fast Gate (< 2 min)      -> mix format --check + Credo + Dialyzer + Unit tests
Standard Gate (< 10 min) -> Integration tests + Contract tests
Invariant Gate (< 3 min) -> File versioning + Loop safety + Agent isolation
Security Gate (< 5 min)  -> Webhook verification + Credential leak + Injection tests
Nightly (< 30 min)       -> E2E + LLM behavioural + Sub-agent DAG + Load tests
```

#### Coverage Targets

- Critical path (orchestrator, sub-agents, file versioning, circuit breakers): 90%+
- Skill implementations: 80%+
- Channel adapters: 80%+
- Memory/compaction: 80%+
- Overall: 75%+

---

## Synthesized Implementation Roadmap

### Phase Sequence

```
PREPARE (research)
    |  - Elixir ecosystem audit, OpenRouter API docs, Google service account setup
    |  - ElevenLabs API, HubSpot API, Railway deployment research
    |  - Elixir best practices guide (in progress)
    |
    v
ARCHITECT (design refinement)
    |  - Finalize OTP supervision tree
    |  - Validate interface contracts
    |  - Sub-agent prompt engineering strategy
    |
    v
CODE Phase 1: Foundation
    |  - Project scaffold + Postgres + schemas
    |  - Skill behaviour + registry + executor
    |  - OpenRouter client (LLM + tool-calling + prompt caching)
    |  - Three meta-tools (get_skill + dispatch_agent + get_agent_results)
    |  - Orchestrator hybrid skill access (read-only direct)
    |  - Circuit breakers (four-level)
    |
    v
CODE Phase 2: Multi-Agent + Memory
    |  - Sub-agent architecture (dispatch_agent, DAG scheduler)
    |  - Memory system (FTS + tags + context assembly)
    |  - Continuous compaction (Oban worker, small model)
    |  - Task management (4-table schema + 5 skills)
    |  - Memory skills (memory.save, memory.search)
    |
    v
CODE Phase 3: First Channel + Integrations
    |  - Google Chat adapter (webhook + bot)
  |  - Google Drive + synced content workflow (service account)
  |  - Basic domain skills: files (read/write/search)
    |  - Notification/alerting system
    |
    v
TEST Phase 1: Core Invariants
    |  - Invariant tests (file safety, loop limits, agent isolation)
    |  - Orchestrator + sub-agent unit tests
    |  - Memory + compaction integration tests
    |
    v
CODE Phase 4: Expand Skills + Channels
    |  - Email, Calendar, HubSpot skills
    |  - Telegram adapter
    |  - Scheduler (Quantum + Oban)
    |
    v
CODE Phase 5: Voice + Polish
    |  - OpenRouter STT integration
    |  - ElevenLabs TTS client (behind TTSClient behaviour)
    |  - WhatsApp adapter
    |
    v
TEST Phase 2: Full Suite
    |  - Integration, security, load, LLM behavioural tests
    |
    v
DEPLOY: Railway
```

### Commit Sequence (Proposed)

> Execution order may differ from numbering. Independent commits may be parallel.

1. `feat: project scaffold with Phoenix + Ecto + Postgres` — Mix project, config, Dockerfile
2. `feat: core schemas and migrations` — Conversations (+ summary fields), messages (+ tool trace columns), memory entries (+ tags, tsvector), memory entities, entity graph, tasks (4 tables), users, execution logs
3. `feat: skill behaviour and registry` — Skill interface, ETS registry, domain/name/search queries
4. `feat: skill executor with Task.Supervisor` — Supervised execution, timeouts
5. `feat: OpenRouter LLM client` — Chat completions, tool-calling, streaming, prompt caching (cache_control)
6. `feat: three meta-tools (get_skill + dispatch_agent + get_agent_results)` — Progressive skill discovery with SKILL.md indexes + dot notation + .all suffix, agent coordination
7. `feat: orchestration engine with hybrid skill access` — Orchestrator loop, read-only direct execution, context assembly, circuit breakers
8. `feat: sub-agent architecture` — CLI command execution, DAG scheduler, scoped context
9. `feat: four-level circuit breaker system` — Per-skill, per-agent, per-turn, per-conversation limits
10. `feat: memory system with hybrid retrieval` — FTS + pgvector + tag/metadata filters, context builder
11. `feat: continuous compaction engine` — Oban worker, incremental fold, small model, summary versioning
12. `feat: task management system` — 4-table schema, 5 skills (create, search, get, update, delete)
13. `feat: memory skills` — memory.save, memory.search as skill modules
14. `feat: Google Chat channel adapter` — Webhook endpoint, bot setup, message normalization
15. `feat: Google Drive + synced content workflow` — Drive client (service account + goth), SYNC/NORMALIZE/ARCHIVE/PUBLISH
16. `test: core invariant test suite` — File safety, loop limits, agent isolation, credential checks
17. `feat: notification and alerting system` — Error routing, dedup, Google Chat webhook, email
18. `feat: email and calendar skills` — Gmail + Calendar API integration
19. `feat: HubSpot CRM skills` — Contacts, deals, notes
20. `feat: files domain skills` — files.read, files.write, files.search, files.move, files.sync
21. `feat: scheduler with Quantum and Oban` — Cron tasks, recurring task generation, job workers
22. `feat: Telegram channel adapter` — Bot API webhook + responses
23. `feat: voice pipeline` — OpenRouter STT + ElevenLabs TTS (behind TTSClient behaviour)
24. `feat: WhatsApp channel adapter` — Business API integration
25. `test: full test suite` — Integration, security, load, LLM behavioural tests
26. `feat: Railway deployment config` — Dockerfile, health checks, env vars, release config

---

## Cross-Cutting Concerns

| Concern | Status | Notes |
|---------|--------|-------|
| Security | Ready | Three-layer prompt injection defense: skill scoping (minimum privilege) + sentinel LLM (context-isolated classifier) + user confirmation for suspicious irreversible actions. Plus: webhook signature verification, credential encryption (Cloak.Ecto), data/instruction boundary delimiters on external content, no credentials in logs. All sentinel decisions logged with reasoning. |
| Performance | Ready | BEAM VM handles concurrency. Sub-agents run in parallel via Task.Supervisor. Prompt caching reduces token costs. FTS queries ~2-5ms. |
| Accessibility | N/A | Backend-only, no UI |
| Observability | Needs attention | Structured logging (Logger metadata), execution_log with parent_execution_id for sub-agent traces, notification system, Telemetry for metrics. |

---

## Open Questions

### Resolved
- [x] **Memory extraction model**: Single continuous conversation per channel (no "conversation ends" event). A **background memory agent** monitors the conversation stream, detects **topic boundaries** (subject shifts), and extracts completed topic segments into structured memory entries. Two parallel async processes: (1) running summary updated every turn (cheap model, 500-token budget) for immediate context, (2) memory extraction triggered by topic shifts or turn-count threshold for long-term storage. Both run via Oban, never interrupt the conversation.
- [x] **TTS fallback behavior**: **Retry once with backoff, then text fallback with notification.** When voice input detected and TTS fails after retry, notify user ("Voice unavailable, sending as text").
- [x] **Sub-agent model selection**: **Curated model roster** — a configured list of available models with descriptions (tier: primary/balanced/fast). Orchestrator selects model per dispatch based on task complexity. If not specified, defaults to orchestrator's own model. Model roster is config-only (add/remove without code changes).

### Require Further Research
- [ ] **OpenRouter prompt caching specifics**: Exact cache_control placement, cache TTL, token accounting
- [ ] **Sub-agent prompt engineering**: Optimal system prompts for sub-agents that maximize tool-use accuracy with minimal context
- [ ] **Recurring task timezone handling**: Cron expression format + timezone support in Quantum

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Elixir ecosystem gaps (thin LLM libs, immature WhatsApp/HubSpot clients) | Medium | Medium | HTTP wrappers behind behaviours. Mox testing isolates from library quality. `Req` is excellent. |
| Multi-agent orchestration complexity | Medium | High | Build single-loop mode first as stepping stone. Feature flag to switch modes. Comprehensive DAG tests. |
| Sub-agent prompt reliability | Medium | Medium | LLM may not always follow dispatch patterns correctly. Mitigate with structured output validation, clear system prompts, fallback to single-loop mode. |
| FTS relevance quality | Medium | Low | FTS + tags + importance weighting may miss conceptually related memories. Mitigated by multiple targeted searches (FTS + tags + high-importance + conversation). pgvector additive later. |
| OpenRouter tool-calling format changes | Low | Medium | Abstract behind `LLMClient` behaviour. Single point of change. |
| Prompt caching effectiveness | Low | Medium | Cache hit rates depend on message ordering discipline. Monitor and tune. |
| Voice latency (STT -> LLM -> sub-agents -> TTS) | Medium | Low | Voice is Phase 5. Multi-agent adds latency vs single-loop. Profile and optimize. Consider single-loop mode for voice. |
| File versioning crash mid-operation | Low | High | Each step logged. Idempotent recovery. Archive-before-replace invariant tested on every PR. |
| Railway deployment constraints | Low | Medium | Phoenix releases well-documented for Docker. Single service + Postgres. |

---

## Scope Assessment

- **Overall Complexity**: Very High (greenfield, multi-agent, multi-integration, new language)
- **Estimated Files**: ~100-120 new files
- **Specialists Required**: Preparer, Architect, Backend Coders (Elixir), Database Engineer, Test Engineer
- **External Dependencies**: OpenRouter (LLM + STT), ElevenLabs (TTS), Google APIs, Telegram API, WhatsApp Business API, HubSpot API, Railway, PostgreSQL

---

## Phase Requirements

| Phase | Required? | Rationale |
|-------|-----------|-----------|
| PREPARE | Yes | 10 unchecked research items (ecosystem audit, API docs, deployment config, best practices guide) |
| ARCHITECT | Yes | OTP supervision tree needs finalization, sub-agent prompt strategy, interface contract validation |
| CODE | Yes | Always required |
| TEST | Yes | Critical invariants (7), security tests, sub-agent DAG tests, integration tests |

---

## Architecture Reference Documents

| Document | Path | Contents |
|----------|------|----------|
| System Architecture | `docs/architecture/system-architecture.md` | C4 diagrams, OTP tree, data architecture, ADRs, security, deployment |
| Two-Tool Architecture | `docs/architecture/two-tool-architecture.md` | CLI-first paradigm, get_skill progressive disclosure, prompt caching |
| Sub-Agent Orchestration | `docs/architecture/sub-agent-orchestration.md` | DAG execution, dispatch_agent, scoped context, limits, Elixir patterns |
| Task Management Design | `docs/architecture/task-management-design.md` | 4-table schema, 5 skills, recurring tasks, notifications, audit trail |
| Markdown Skill System | `docs/architecture/markdown-skill-system.md` | Skill definition format, dot notation, SKILL.md indexes, progressive disclosure, workflow builder, handler patterns |

---

## Next Steps

To implement this plan after approval:
```
/PACT:orchestrate Build skills-first AI assistant per approved plan
```

The orchestrator will reference this plan during execution, starting with PREPARE phase to resolve remaining research items.
