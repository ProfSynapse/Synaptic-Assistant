# API Documentation Reference (2026-02-17)

> Comprehensive endpoint specs for all Synaptic Assistant integrations.
> Target audience: Elixir developer building Req-based HTTP clients behind behaviours.

---

## Table of Contents

1. [OpenRouter API](#1-openrouter-api)
2. [Google Chat API](#2-google-chat-api)
3. [Google Drive API](#3-google-drive-api)
4. [Google Gmail API](#4-google-gmail-api)
5. [Google Calendar API](#5-google-calendar-api)
6. [Telegram Bot API](#6-telegram-bot-api)
7. [WhatsApp Business Cloud API](#7-whatsapp-business-cloud-api)
8. [HubSpot CRM API](#8-hubspot-crm-api)
9. [ElevenLabs API](#9-elevenlabs-api)
10. [Slack API](#10-slack-api)

---

## 1. OpenRouter API

### Overview

OpenRouter normalizes the OpenAI chat completions schema across 400+ models and providers. Single endpoint for LLM calls, tool-calling, streaming, and audio input.

### Base URL

```
https://openrouter.ai/api/v1
```

### Authentication

```
Authorization: Bearer <OPENROUTER_API_KEY>
Content-Type: application/json
```

### Key Endpoints

#### POST /chat/completions

Primary endpoint for LLM calls, tool-calling, and audio transcription.

**Request body:**

```json
{
  "model": "anthropic/claude-sonnet-4",
  "messages": [
    {"role": "system", "content": "You are a helpful assistant."},
    {"role": "user", "content": "Hello"}
  ],
  "tools": [],
  "tool_choice": "auto",
  "stream": false,
  "temperature": 1,
  "max_tokens": 4096
}
```

**Core parameters:**

| Parameter | Type | Required | Notes |
|-----------|------|----------|-------|
| `model` | string | Yes* | Model ID (e.g. `anthropic/claude-sonnet-4`). *Either `model` or `models` required. |
| `models` | string[] | No | Fallback model list |
| `messages` | Message[] | Yes | Conversation messages |
| `stream` | boolean | No | Default `false`. Set `true` for SSE streaming. |
| `temperature` | number | No | Default 1 |
| `max_tokens` | number | No | Max completion tokens |
| `tools` | Tool[] | No | Tool definitions for function calling |
| `tool_choice` | string/object | No | `"auto"`, `"none"`, `"required"`, or `{"type":"function","function":{"name":"..."}}` |
| `parallel_tool_calls` | boolean | No | Set `false` for sequential tool calls |
| `response_format` | object | No | `{"type":"json_object"}` or `{"type":"json_schema","json_schema":{...}}` |
| `provider` | object | No | Routing preferences: `order`, `only`, `ignore`, `sort` |

**Response (non-streaming):**

```json
{
  "id": "gen-xxx",
  "object": "chat.completion",
  "created": 1708000000,
  "model": "anthropic/claude-sonnet-4",
  "choices": [
    {
      "index": 0,
      "finish_reason": "stop",
      "message": {
        "role": "assistant",
        "content": "Hello! How can I help you?"
      }
    }
  ],
  "usage": {
    "prompt_tokens": 25,
    "completion_tokens": 10,
    "total_tokens": 35,
    "prompt_tokens_details": {
      "cached_tokens": 0,
      "cache_write_tokens": 0,
      "audio_tokens": 0,
      "video_tokens": 0
    }
  }
}
```

**Finish reason values:** `"stop"`, `"tool_calls"`, `"length"`, `"content_filter"`, `"error"`

**Error responses:** `400` (bad params), `401` (invalid key), `402` (insufficient credits), `429` (rate limit), `502`/`503` (provider error)

---

#### Tool-Calling Format

**Tool definition structure:**

```json
{
  "type": "function",
  "function": {
    "name": "get_skill",
    "description": "Discover available skills",
    "parameters": {
      "type": "object",
      "properties": {
        "domain": {
          "type": "string",
          "description": "Skill domain to look up"
        }
      },
      "required": ["domain"]
    }
  }
}
```

**Assistant response with tool calls:**

```json
{
  "role": "assistant",
  "content": null,
  "tool_calls": [
    {
      "id": "call_abc123",
      "type": "function",
      "function": {
        "name": "get_skill",
        "arguments": "{\"domain\": \"email\"}"
      }
    }
  ]
}
```

**Sending tool results back:**

```json
{
  "role": "tool",
  "tool_call_id": "call_abc123",
  "content": "email.send  Send an email\nemail.search  Search emails"
}
```

**Important:** The `tools` array must be included in every request in the conversation (both initial and follow-up) for validation.

---

#### Streaming (SSE)

Enable with `"stream": true`. Response is Server-Sent Events.

**Chunk format:**

```
data: {"id":"gen-xxx","object":"chat.completion.chunk","created":1708000000,"model":"anthropic/claude-sonnet-4","choices":[{"index":0,"delta":{"content":"Hello"},"finish_reason":null}]}

data: {"id":"gen-xxx","object":"chat.completion.chunk","choices":[{"index":0,"delta":{},"finish_reason":"stop"}],"usage":{"prompt_tokens":25,"completion_tokens":10,"total_tokens":35}}

data: [DONE]
```

**Gotchas:**
- OpenRouter sends SSE comment frames (`: OPENROUTER PROCESSING`) to prevent timeouts -- ignore these
- Mid-stream errors arrive as SSE events with `finish_reason: "error"` (HTTP 200 since headers already sent)
- Final chunk includes `usage` data
- Stream cancellation supported for most providers (Anthropic, OpenAI, etc.)
- Include `"stream_options": {"include_usage": true}` to guarantee usage in final chunk

---

#### Prompt Caching

Place `cache_control` breakpoints on large stable content blocks in message content arrays.

**Placement syntax:**

```json
{
  "role": "system",
  "content": [
    {
      "type": "text",
      "text": "Large system prompt with policy text, skill definitions, etc...",
      "cache_control": {"type": "ephemeral"}
    }
  ]
}
```

**Provider-specific behavior:**

| Provider | Mechanism | Min Tokens | TTL | Write Cost | Read Discount |
|----------|-----------|------------|-----|------------|---------------|
| **Anthropic** | Manual `cache_control` (max 4 breakpoints) | 1024-4096 (varies by model) | 5 min default, 1 hour with `"ttl":"1h"` | 1.25x-2x base | 0.1x base |
| **Gemini** | Implicit (2.5 Pro/Flash) + manual `cache_control` | 1028 (Flash), 2048 (Pro) | Automatic | -- | 0.25x base |
| **OpenAI** | Automatic (no setup) | 1024 | Automatic | -- | 0.25x-0.50x base |

**1-hour TTL for Anthropic:**

```json
{"cache_control": {"type": "ephemeral", "ttl": "1h"}}
```

**Usage response fields:**
- `usage.prompt_tokens_details.cached_tokens` -- tokens read from cache
- `usage.prompt_tokens_details.cache_write_tokens` -- tokens written to cache

**Best practices:**
- Place cache breakpoints on system prompt + tool definitions (stable content first)
- For Gemini, only the last breakpoint is used (safe to include multiple for Anthropic compat)
- Sort tool definitions alphabetically for consistent cache keys across sub-agents

---

#### Audio Input (STT via Chat Completions)

OpenRouter does NOT have a dedicated `/audio/transcriptions` endpoint. Audio transcription is handled through the chat completions endpoint with multipart content.

**Audio message format:**

```json
{
  "model": "google/gemini-2.5-flash",
  "messages": [
    {
      "role": "user",
      "content": [
        {"type": "text", "text": "Transcribe this audio."},
        {
          "type": "input_audio",
          "input_audio": {
            "data": "<base64-encoded-audio>",
            "format": "wav"
          }
        }
      ]
    }
  ]
}
```

**Key constraints:**
- Audio must be **base64-encoded** (direct URLs not supported)
- Supported formats: WAV, MP3, AIFF, AAC, OGG, FLAC, M4A, PCM16, PCM24 (check model docs for specific support)
- Use audio-capable models (filter at openrouter.ai/models by audio input modality)
- Response is a text completion containing the transcription

**Elixir/Req note:** Read audio file, Base64-encode with `:base64.encode/1`, embed in the content array. No multipart form upload needed -- it is all JSON.

---

#### GET /models

List all available models.

```
GET https://openrouter.ai/api/v1/models
Authorization: Bearer <OPENROUTER_API_KEY>
```

**Optional query params:** `category`, `supported_parameters`

**Response:** Array of model objects with `id`, `name`, `pricing`, `context_length`, `top_provider`, etc.

---

### Rate Limits

OpenRouter rate limits vary by plan and model. Rate limit headers are returned with each response. Per-model limits are documented on the models page. 429 status with `Retry-After` header when exceeded.

### Elixir/Req Notes

- All requests are `POST` to `/api/v1/chat/completions` with JSON body
- Use `Req.post!` with `json:` option for the body and `auth: {:bearer, api_key}` for auth
- For streaming, use `into:` option with a stream handler to process SSE chunks
- Tool call arguments arrive as JSON strings -- `Jason.decode!/1` the `arguments` field
- Wrap in a `LLMClient` behaviour to abstract provider specifics

---

## 2. Google Chat API

### Overview

Google Chat apps receive interaction events (messages, card clicks) via HTTP endpoint, Apps Script, or Pub/Sub. The app responds synchronously or sends async messages via REST API.

### Base URL

```
https://chat.googleapis.com/v1
```

### Authentication

Service account with `chat.bot` scope. Use `goth` to mint tokens. The `chat.bot` scope is self-granted by the Chat app (no admin consent needed for bot-to-space operations).

**Required scopes (pick one):**
- `https://www.googleapis.com/auth/chat.bot` (recommended for bot operations)
- `https://www.googleapis.com/auth/chat.messages` (broader -- for user-context operations)
- `https://www.googleapis.com/auth/chat.messages.create` (send only)

### Key Endpoints

#### Receiving Messages (Interaction Events)

Google Chat sends `MESSAGE` events to your configured HTTP endpoint as POST requests with a JSON body.

**Inbound event structure:**

```json
{
  "type": "MESSAGE",
  "eventTime": "2026-02-17T10:30:00.000Z",
  "message": {
    "name": "spaces/SPACE_ID/messages/MSG_ID",
    "sender": {
      "name": "users/USER_ID",
      "displayName": "John Doe",
      "email": "john@example.com",
      "type": "HUMAN"
    },
    "createTime": "2026-02-17T10:30:00.000Z",
    "text": "Hello @AssistantBot",
    "argumentText": "Hello",
    "thread": {
      "name": "spaces/SPACE_ID/threads/THREAD_ID"
    },
    "space": {
      "name": "spaces/SPACE_ID",
      "type": "ROOM"
    },
    "annotations": []
  },
  "user": {
    "name": "users/USER_ID",
    "displayName": "John Doe",
    "email": "john@example.com"
  },
  "space": {
    "name": "spaces/SPACE_ID"
  }
}
```

**Event types:** `MESSAGE`, `ADDED_TO_SPACE`, `REMOVED_FROM_SPACE`, `CARD_CLICKED`

**Synchronous response requirement:** Must respond within **30 seconds** with a `Message` object.

**Synchronous response format:**

```json
{
  "text": "Hello! I'm processing your request."
}
```

---

#### POST /v1/{parent=spaces/*}/messages

Create a message in a space (async responses, notifications).

**Request:**

```
POST https://chat.googleapis.com/v1/spaces/SPACE_ID/messages
Authorization: Bearer <service-account-token>
Content-Type: application/json
```

```json
{
  "text": "Here is the result of your query."
}
```

**With cards (app auth only):**

```json
{
  "text": "Fallback text",
  "cardsV2": [
    {
      "cardId": "card1",
      "card": {
        "header": {"title": "Task Created"},
        "sections": [
          {
            "widgets": [
              {"textParagraph": {"text": "Task #42 has been created."}}
            ]
          }
        ]
      }
    }
  ]
}
```

**Query params:**
- `threadKey` (string): Thread ID (for threading replies)
- `requestId` (string): Idempotency key
- `messageReplyOption`: `REPLY_MESSAGE_FALLBACK_TO_NEW_THREAD` or `REPLY_MESSAGE_OR_FAIL`

**Response:** Created `Message` object with `name` and `thread.name`.

**Max message size:** 32,000 bytes.

### Rate Limits

- `spaces.messages.create`: **1 request per second per space** (shared across all webhooks in that space)
- Quota: 60 requests per minute per project

### Webhook Verification

Google Chat does not use signature-based webhook verification like Telegram/Slack. Instead, authentication is handled through:
1. Google Cloud project configuration (only your project can receive events for your bot)
2. Bearer token verification on outbound API calls

### Elixir/Req Notes

- Use `goth` to get service account tokens: `Goth.Token.for_scope("https://www.googleapis.com/auth/chat.bot")`
- Inbound events arrive at your Phoenix endpoint -- parse JSON body, match on `type` field
- For async responses, POST to `https://chat.googleapis.com/v1/spaces/{space_id}/messages`
- Thread replies: include `threadKey` param and `messageReplyOption` query param

---

## 3. Google Drive API

### Overview

RESTful API for file CRUD, export (Google Docs to other formats), and permissions. Used for synced content workspace.

### Base URL

```
https://www.googleapis.com/drive/v3
```

### Authentication

Service account with domain-wide delegation via `goth`. Impersonate the target user with `sub` claim.

**Scopes:**
- `https://www.googleapis.com/auth/drive` (full access)
- `https://www.googleapis.com/auth/drive.file` (files created/opened by the app)
- `https://www.googleapis.com/auth/drive.readonly` (read only)

### Key Endpoints

| Method | HTTP | Path | Purpose |
|--------|------|------|---------|
| list | GET | `/files` | List files with query filter |
| get | GET | `/files/{fileId}` | Get file metadata |
| get (download) | GET | `/files/{fileId}?alt=media` | Download file content |
| create | POST | `/files` | Create file (metadata or upload) |
| update | PATCH | `/files/{fileId}` | Update metadata or content |
| export | GET | `/files/{fileId}/export` | Export Google Workspace doc to MIME type |

---

#### GET /files (list)

```
GET https://www.googleapis.com/drive/v3/files?q=name%20contains%20'report'&fields=files(id,name,mimeType,modifiedTime)
Authorization: Bearer <token>
```

**Key params:**
- `q` (string): Search query (e.g. `"name contains 'report' and mimeType = 'application/vnd.google-apps.document'"`)
- `fields` (string): Partial response fields (use to reduce payload)
- `pageSize` (int): Max results per page (default 100, max 1000)
- `pageToken` (string): Pagination token
- `orderBy` (string): e.g. `"modifiedTime desc"`

**Response:**

```json
{
  "kind": "drive#fileList",
  "nextPageToken": "...",
  "files": [
    {"id": "FILE_ID", "name": "Q1 Report", "mimeType": "application/vnd.google-apps.document", "modifiedTime": "2026-02-17T10:00:00.000Z"}
  ]
}
```

---

#### GET /files/{fileId} (get metadata)

```
GET https://www.googleapis.com/drive/v3/files/FILE_ID?fields=id,name,mimeType,size,modifiedTime,parents
Authorization: Bearer <token>
```

---

#### GET /files/{fileId}?alt=media (download content)

Returns raw file bytes. For Google Workspace docs, use `export` instead.

---

#### GET /files/{fileId}/export

Export Google Docs, Sheets, Slides to another format.

```
GET https://www.googleapis.com/drive/v3/files/FILE_ID/export?mimeType=text/plain
Authorization: Bearer <token>
```

**Export MIME types for Google Docs:**
- `text/plain` (plain text)
- `text/html` (HTML)
- `application/pdf` (PDF)
- `application/vnd.openxmlformats-officedocument.wordprocessingml.document` (DOCX)

**Limit:** Exported content capped at **10 MB**.

---

#### POST /files (create)

**Metadata-only create:**

```
POST https://www.googleapis.com/drive/v3/files
Authorization: Bearer <token>
Content-Type: application/json

{"name": "New Document", "mimeType": "application/vnd.google-apps.document", "parents": ["FOLDER_ID"]}
```

**Upload with content:** Use multipart upload to `https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart`

---

#### PATCH /files/{fileId} (update)

```
PATCH https://www.googleapis.com/drive/v3/files/FILE_ID
Authorization: Bearer <token>
Content-Type: application/json

{"name": "Renamed Document"}
```

### Rate Limits

- Per-user: 12,000 requests per 60 seconds
- Per-project: 1,000,000,000 queries per day

### Elixir/Req Notes

- Use `goth` with `sub` (impersonated user email) for DWD: `Goth.Token.for_scope(scopes, %{sub: "user@domain.com"})`
- For file exports (Google Docs -> markdown), export as `text/plain` or `text/html` then convert
- The `fields` param is important -- without it, responses include minimal metadata
- Multipart uploads require `Content-Type: multipart/related` with metadata JSON + file content parts

---

## 4. Google Gmail API

### Overview

REST API for reading, sending, and managing email. Used with service account + domain-wide delegation.

### Base URL

```
https://gmail.googleapis.com/gmail/v1
```

### Authentication

Service account + DWD via `goth`. Impersonate user with `sub` claim.

**Scopes:**
- `https://www.googleapis.com/auth/gmail.readonly` (read)
- `https://www.googleapis.com/auth/gmail.send` (send)
- `https://www.googleapis.com/auth/gmail.modify` (read + write + labels)
- `https://www.googleapis.com/auth/gmail.compose` (create + send drafts)

### Key Endpoints

| Method | HTTP | Path | Purpose |
|--------|------|------|---------|
| list | GET | `/users/{userId}/messages` | List messages |
| get | GET | `/users/{userId}/messages/{id}` | Get message |
| send | POST | `/users/{userId}/messages/send` | Send message |
| modify | POST | `/users/{userId}/messages/{id}/modify` | Add/remove labels |
| drafts.create | POST | `/users/{userId}/drafts` | Create draft |

**Note:** `{userId}` is typically `"me"` (authenticated user) or the impersonated email address.

---

#### GET /users/{userId}/messages (list)

```
GET https://gmail.googleapis.com/gmail/v1/users/me/messages?q=is:unread after:2026/02/16&maxResults=20
Authorization: Bearer <token>
```

**Params:**
- `q` (string): Gmail search query (same syntax as Gmail search box)
- `labelIds` (string[]): Filter by labels
- `maxResults` (int): Max messages (default 100)
- `pageToken` (string): Pagination

**Response:**

```json
{
  "messages": [
    {"id": "MSG_ID", "threadId": "THREAD_ID"}
  ],
  "nextPageToken": "...",
  "resultSizeEstimate": 42
}
```

**Note:** List returns only IDs. Use `get` with `format=FULL` for content.

---

#### GET /users/{userId}/messages/{id} (get)

```
GET https://gmail.googleapis.com/gmail/v1/users/me/messages/MSG_ID?format=full
Authorization: Bearer <token>
```

**`format` options:** `MINIMAL`, `FULL` (default), `RAW`, `METADATA`

**Response (FULL):** Includes `payload.headers` (From, To, Subject, Date), `payload.body.data` (base64url-encoded), `payload.parts` for MIME multipart.

---

#### POST /users/{userId}/messages/send

Send requires a base64url-encoded RFC 2822 email message.

```
POST https://gmail.googleapis.com/gmail/v1/users/me/messages/send
Authorization: Bearer <token>
Content-Type: application/json

{
  "raw": "<base64url-encoded-rfc2822-message>"
}
```

**Building the raw message in Elixir:**

```
"From: assistant@domain.com\r\nTo: bob@example.com\r\nSubject: Q1 Report\r\nContent-Type: text/plain; charset=utf-8\r\n\r\nHere is the report."
|> Base.url_encode64(padding: false)
```

---

#### POST /users/{userId}/messages/{id}/modify

```json
{
  "addLabelIds": ["Label_1"],
  "removeLabelIds": ["UNREAD"]
}
```

---

#### POST /users/{userId}/drafts (create)

```
POST https://gmail.googleapis.com/gmail/v1/users/me/drafts
Authorization: Bearer <token>
Content-Type: application/json

{
  "message": {
    "raw": "<base64url-encoded-rfc2822-message>"
  }
}
```

### Rate Limits

- Per-user: 250 quota units per second
- Sending: 100 messages per day per user (varies by Workspace edition)

### Elixir/Req Notes

- Messages are base64url-encoded RFC 2822 format. Use `:base64.encode/1` with URL-safe variant (`Base.url_encode64/2` with `padding: false`)
- The `q` parameter supports full Gmail search syntax: `is:unread`, `from:`, `subject:`, `after:`, `has:attachment`, etc.
- List + Get is a two-step pattern: list returns IDs, then batch-get for content
- For DWD, use `goth` with `sub: "user@domain.com"` in token request

---

## 5. Google Calendar API

### Overview

REST API for calendar event CRUD. Used with service account + domain-wide delegation.

### Base URL

```
https://www.googleapis.com/calendar/v3
```

### Authentication

Service account + DWD via `goth`.

**Scopes:**
- `https://www.googleapis.com/auth/calendar` (full read/write)
- `https://www.googleapis.com/auth/calendar.readonly` (read only)
- `https://www.googleapis.com/auth/calendar.events` (event CRUD)

### Key Endpoints

| Method | HTTP | Path | Purpose |
|--------|------|------|---------|
| list | GET | `/calendars/{calendarId}/events` | List events |
| get | GET | `/calendars/{calendarId}/events/{eventId}` | Get event |
| insert | POST | `/calendars/{calendarId}/events` | Create event |
| update | PUT | `/calendars/{calendarId}/events/{eventId}` | Update event (full replace) |

**Note:** `{calendarId}` is typically `"primary"` for the user's default calendar, or a specific calendar ID.

---

#### GET /calendars/{calendarId}/events (list)

```
GET https://www.googleapis.com/calendar/v3/calendars/primary/events?timeMin=2026-02-17T00:00:00Z&timeMax=2026-02-18T00:00:00Z&singleEvents=true&orderBy=startTime
Authorization: Bearer <token>
```

**Key params:**
- `timeMin` / `timeMax` (datetime): Filter range (RFC 3339)
- `singleEvents` (boolean): Expand recurring events
- `orderBy` (string): `startTime` (requires `singleEvents=true`) or `updated`
- `q` (string): Free text search
- `maxResults` (int): Max events
- `pageToken` (string): Pagination

**Response:**

```json
{
  "kind": "calendar#events",
  "items": [
    {
      "id": "EVENT_ID",
      "summary": "Team Meeting",
      "start": {"dateTime": "2026-02-17T10:00:00+02:00"},
      "end": {"dateTime": "2026-02-17T11:00:00+02:00"},
      "attendees": [{"email": "bob@example.com", "responseStatus": "accepted"}],
      "location": "Room A",
      "description": "Weekly sync"
    }
  ]
}
```

---

#### POST /calendars/{calendarId}/events (insert)

```
POST https://www.googleapis.com/calendar/v3/calendars/primary/events
Authorization: Bearer <token>
Content-Type: application/json

{
  "summary": "Review Meeting",
  "start": {"dateTime": "2026-02-18T14:00:00+02:00"},
  "end": {"dateTime": "2026-02-18T15:00:00+02:00"},
  "attendees": [
    {"email": "bob@example.com"},
    {"email": "alice@example.com"}
  ],
  "description": "Quarterly review",
  "location": "Conference Room B"
}
```

---

#### PUT /calendars/{calendarId}/events/{eventId} (update)

Full resource replacement (not PATCH). Must send the complete event object.

```
PUT https://www.googleapis.com/calendar/v3/calendars/primary/events/EVENT_ID
Authorization: Bearer <token>
Content-Type: application/json

{ ...full event object... }
```

**Gotcha:** This is PUT, not PATCH. Omitted fields will be cleared. Always GET first, modify, then PUT.

### Rate Limits

- Per-user: 2,500 requests per 100 seconds
- Per-project: 1,000,000 requests per day

### Elixir/Req Notes

- Datetime values must be RFC 3339 format with timezone offset
- For all-day events, use `{"date": "2026-02-17"}` instead of `dateTime`
- Calendar API update is PUT (full replace), not PATCH -- always fetch-modify-write
- Use `goth` with DWD for impersonating calendar owners

---

## 6. Telegram Bot API

### Overview

HTTP-based API for Telegram bots. Send/receive messages via webhooks. Token-in-URL authentication.

### Base URL

```
https://api.telegram.org/bot<BOT_TOKEN>/
```

All methods are called as: `https://api.telegram.org/bot<BOT_TOKEN>/<METHOD_NAME>`

### Authentication

Bot token embedded in the URL path. No Authorization header needed.

### Key Endpoints

#### POST /setWebhook

Configure webhook URL for receiving updates.

```json
{
  "url": "https://your-domain.com/webhooks/telegram",
  "secret_token": "your-secret-token-string",
  "max_connections": 40,
  "allowed_updates": ["message", "edited_message", "callback_query"]
}
```

**Parameters:**
- `url` (string, required): HTTPS URL
- `secret_token` (string, optional): 1-256 chars, `[A-Za-z0-9_-]` only
- `max_connections` (int, optional): 1-100, default 40
- `allowed_updates` (string[], optional): Filter update types
- `certificate` (InputFile, optional): Self-signed cert for verification
- `drop_pending_updates` (boolean, optional): Drop queued updates

**Supported ports:** 443, 80, 88, 8443

---

#### Inbound Update Format (webhook POST to your endpoint)

Telegram POSTs a JSON `Update` object to your webhook URL:

```json
{
  "update_id": 123456789,
  "message": {
    "message_id": 42,
    "from": {
      "id": 12345,
      "is_bot": false,
      "first_name": "John",
      "username": "johndoe"
    },
    "chat": {
      "id": 12345,
      "type": "private",
      "first_name": "John"
    },
    "date": 1708000000,
    "text": "Hello bot!"
  }
}
```

**Update fields (at most one present):** `message`, `edited_message`, `channel_post`, `callback_query`, `inline_query`

---

#### POST /sendMessage

```json
{
  "chat_id": 12345,
  "text": "Hello! Here is your report.",
  "parse_mode": "HTML",
  "reply_markup": {
    "inline_keyboard": [
      [{"text": "View Details", "callback_data": "view_42"}]
    ]
  }
}
```

**Parameters:**
- `chat_id` (int/string, required): Target chat
- `text` (string, required): Message text
- `parse_mode` (string, optional): `HTML`, `Markdown`, `MarkdownV2`
- `reply_markup` (object, optional): Inline keyboard, reply keyboard, etc.
- `reply_to_message_id` (int, optional): Reply to a specific message

---

#### POST /sendDocument

```json
{
  "chat_id": 12345,
  "document": "<file_id or URL>",
  "caption": "Q1 Report"
}
```

**Parameters:**
- `chat_id` (int/string, required): Target chat
- `document` (InputFile/string, required): File to send (file_id, URL, or multipart upload)
- `caption` (string, optional): Document caption
- `parse_mode` (string, optional): Caption formatting

**Note:** Sending by URL only works for `.PDF` and `.ZIP` files.

### Webhook Verification

When `secret_token` is set in `setWebhook`, Telegram includes the header:

```
X-Telegram-Bot-Api-Secret-Token: <your-secret-token>
```

Verify this header matches your configured token. Reject requests with missing or mismatched tokens.

### Rate Limits

- Messages: ~30 messages per second to different chats
- Same chat: ~1 message per second
- Group chats: ~20 messages per minute per group

### Elixir/Req Notes

- All methods are POST to `https://api.telegram.org/bot#{token}/#{method}`
- Use `Req.post!(url, json: params)` for all calls
- For file uploads (sendDocument with local file), use multipart: `Req.post!(url, form_multipart: [document: {file_content, filename: "report.pdf"}])`
- Webhook handler: Phoenix controller that parses Update JSON, verifies `X-Telegram-Bot-Api-Secret-Token` header

---

## 7. WhatsApp Business Cloud API

### Overview

Meta's Cloud API for WhatsApp Business messaging. Webhook-based inbound, REST-based outbound.

### Base URL

```
https://graph.facebook.com/v21.0
```

(Use latest stable API version; v17.0+ supported. Current: v21.0)

### Authentication

```
Authorization: Bearer <SYSTEM_USER_ACCESS_TOKEN>
Content-Type: application/json
```

System User Access Token from Meta Business Manager. Long-lived (does not expire but can be revoked).

### Key Endpoints

#### Webhook Verification (GET)

When configuring webhooks, Meta sends a GET request to verify your endpoint:

```
GET /your-webhook-url?hub.mode=subscribe&hub.challenge=CHALLENGE_STRING&hub.verify_token=YOUR_VERIFY_TOKEN
```

**Your endpoint must:**
1. Check `hub.mode` == `"subscribe"`
2. Check `hub.verify_token` matches your configured token
3. Respond with `hub.challenge` value (plain text, 200 status)

```elixir
# Phoenix controller
def verify(conn, %{"hub.mode" => "subscribe", "hub.challenge" => challenge, "hub.verify_token" => token}) do
  if token == configured_verify_token() do
    send_resp(conn, 200, challenge)
  else
    send_resp(conn, 403, "Forbidden")
  end
end
```

---

#### Webhook Payload (POST -- inbound messages)

Meta POSTs to your webhook URL when messages arrive:

```json
{
  "object": "whatsapp_business_account",
  "entry": [
    {
      "id": "WHATSAPP_BUSINESS_ACCOUNT_ID",
      "changes": [
        {
          "field": "messages",
          "value": {
            "messaging_product": "whatsapp",
            "metadata": {
              "display_phone_number": "15551234567",
              "phone_number_id": "PHONE_NUMBER_ID"
            },
            "contacts": [
              {
                "profile": {"name": "John Doe"},
                "wa_id": "15559876543"
              }
            ],
            "messages": [
              {
                "from": "15559876543",
                "id": "wamid.xxx",
                "timestamp": "1708000000",
                "type": "text",
                "text": {"body": "Hello assistant"}
              }
            ]
          }
        }
      ]
    }
  ]
}
```

**Message path:** `entry[0].changes[0].value.messages[0]`

**Message types:** `text`, `image`, `audio`, `document`, `video`, `location`, `contacts`, `interactive`, `button`

**Status updates** also arrive via webhook in `entry[0].changes[0].value.statuses[]`:

```json
{
  "id": "wamid.xxx",
  "status": "delivered",
  "timestamp": "1708000001",
  "recipient_id": "15559876543"
}
```

---

#### POST /{phone_number_id}/messages (send message)

```
POST https://graph.facebook.com/v21.0/PHONE_NUMBER_ID/messages
Authorization: Bearer <ACCESS_TOKEN>
Content-Type: application/json
```

**Text message:**

```json
{
  "messaging_product": "whatsapp",
  "recipient_type": "individual",
  "to": "15559876543",
  "type": "text",
  "text": {"body": "Hello! Here is your update."}
}
```

**Template message (required for business-initiated conversations):**

```json
{
  "messaging_product": "whatsapp",
  "to": "15559876543",
  "type": "template",
  "template": {
    "name": "hello_world",
    "language": {"code": "en_US"},
    "components": []
  }
}
```

**Response:**

```json
{
  "messaging_product": "whatsapp",
  "contacts": [{"wa_id": "15559876543"}],
  "messages": [{"id": "wamid.xxx"}]
}
```

### Rate Limits

- Messaging: Tiered based on phone number quality rating and messaging limits tier
- Tier 1: 1,000 business-initiated conversations per 24 hours
- Tier 2: 10,000; Tier 3: 100,000; Tier 4: unlimited
- User-reply window: 24 hours after last user message (free-form replies allowed within window)

### Template Requirements

- Business-initiated messages outside the 24-hour reply window **must** use pre-approved templates
- Templates are registered and approved via Meta Business Manager
- Template messages incur conversation-based pricing

### Elixir/Req Notes

- Webhook verification is a GET endpoint that returns the challenge string
- Webhook payloads are deeply nested -- extract messages via `entry -> changes -> value -> messages`
- The `phone_number_id` in the URL is from your WhatsApp Business Account, not the recipient
- System User Access Tokens are long-lived but should be stored securely (env var)

---

## 8. HubSpot CRM API

### Overview

RESTful API for CRM operations. V3 endpoints for Contacts, Deals, Notes. Private App access token authentication.

### Base URL

```
https://api.hubapi.com
```

### Authentication

```
Authorization: Bearer <PRIVATE_APP_ACCESS_TOKEN>
Content-Type: application/json
```

Private App tokens are created in HubSpot Settings > Integrations > Private Apps. Tokens are long-lived (no expiry) but scoped to selected permissions.

### Key Endpoints

#### Contacts

| Method | HTTP | Path | Purpose |
|--------|------|------|---------|
| Search | POST | `/crm/v3/objects/contacts/search` | Search contacts |
| Get | GET | `/crm/v3/objects/contacts/{contactId}` | Get contact |
| Create | POST | `/crm/v3/objects/contacts` | Create contact |
| Update | PATCH | `/crm/v3/objects/contacts/{contactId}` | Update contact |

**Search contacts:**

```
POST https://api.hubapi.com/crm/v3/objects/contacts/search
```

```json
{
  "filterGroups": [
    {
      "filters": [
        {
          "propertyName": "email",
          "operator": "EQ",
          "value": "anna@example.com"
        }
      ]
    }
  ],
  "properties": ["email", "firstname", "lastname", "phone"],
  "limit": 10,
  "after": 0
}
```

**Search operators:** `EQ`, `NEQ`, `LT`, `LTE`, `GT`, `GTE`, `CONTAINS_TOKEN`, `NOT_CONTAINS_TOKEN`, `HAS_PROPERTY`, `NOT_HAS_PROPERTY`

**Create contact:**

```
POST https://api.hubapi.com/crm/v3/objects/contacts
```

```json
{
  "properties": {
    "email": "anna@example.com",
    "firstname": "Anna",
    "lastname": "Smith",
    "phone": "+1-555-123-4567"
  }
}
```

**Update contact:**

```
PATCH https://api.hubapi.com/crm/v3/objects/contacts/CONTACT_ID
```

```json
{
  "properties": {
    "phone": "+1-555-999-0000"
  }
}
```

---

#### Deals

| Method | HTTP | Path | Purpose |
|--------|------|------|---------|
| Search | POST | `/crm/v3/objects/deals/search` | Search deals |
| Get | GET | `/crm/v3/objects/deals/{dealId}` | Get deal |
| Create | POST | `/crm/v3/objects/deals` | Create deal |
| Update | PATCH | `/crm/v3/objects/deals/{dealId}` | Update deal |

**Create deal:**

```
POST https://api.hubapi.com/crm/v3/objects/deals
```

```json
{
  "properties": {
    "dealname": "New Enterprise Deal",
    "dealstage": "appointmentscheduled",
    "pipeline": "default",
    "amount": "50000",
    "closedate": "2026-03-15"
  }
}
```

---

#### Notes (Engagements)

| Method | HTTP | Path | Purpose |
|--------|------|------|---------|
| Create | POST | `/crm/v3/objects/notes` | Create note |
| Get | GET | `/crm/v3/objects/notes/{noteId}` | Get note |
| List by object | GET | `/crm/v3/objects/contacts/{id}/associations/notes` | List notes for a contact |

**Create note:**

```
POST https://api.hubapi.com/crm/v3/objects/notes
```

```json
{
  "properties": {
    "hs_note_body": "Spoke with Anna about Q1 goals. She is interested in the enterprise plan.",
    "hs_timestamp": "2026-02-17T10:30:00.000Z"
  }
}
```

**Associate note with contact (v4 Associations API):**

```
PUT https://api.hubapi.com/crm/v4/objects/notes/{noteId}/associations/contacts/{contactId}
```

```json
[
  {
    "associationCategory": "HUBSPOT_DEFINED",
    "associationTypeId": 202
  }
]
```

**Common association type IDs:**
- Note -> Contact: `202`
- Note -> Company: `190`
- Note -> Deal: `214`

**List notes for contact:**

```
GET https://api.hubapi.com/crm/v3/objects/contacts/CONTACT_ID/associations/notes
```

### Rate Limits

| Tier | Burst (per 10 sec) | Daily |
|------|-------------------|-------|
| Free/Starter | 100/app | 250,000/account |
| Professional | 190/app | 625,000/account |
| Enterprise | 190/app | 1,000,000/account |

**Search API:** Separate limit -- **4 requests per second**

**Rate limit response:** HTTP `429` with body indicating `DAILY` or `SECONDLY` limit exceeded.

**Rate limit headers:**
- `X-HubSpot-RateLimit-Max`
- `X-HubSpot-RateLimit-Remaining`
- `X-HubSpot-RateLimit-Interval-Milliseconds`

### Elixir/Req Notes

- All CRM objects follow the same pattern: `/crm/v3/objects/{objectType}` for CRUD
- Search endpoint uses POST with `filterGroups` array of `filters`
- Property names are lowercase with underscores (HubSpot internal names)
- Associations use the v4 API (`/crm/v4/objects/...`) with `associationTypeId`
- Rate limit the search client separately (4 req/sec) from general CRUD (100-190 req/10sec)
- Use `Req.get!` response headers to track remaining quota

---

## 9. ElevenLabs API

### Overview

TTS API for converting text to speech. Supports streaming and non-streaming. Multiple voices and models.

### Base URL

```
https://api.elevenlabs.io
```

### Authentication

```
xi-api-key: <ELEVENLABS_API_KEY>
Content-Type: application/json
```

### Key Endpoints

#### POST /v1/text-to-speech/{voice_id} (non-streaming)

Returns complete audio file.

```
POST https://api.elevenlabs.io/v1/text-to-speech/VOICE_ID?output_format=mp3_44100_128
xi-api-key: <API_KEY>
Content-Type: application/json
```

```json
{
  "text": "Hello, this is a test of the text to speech system.",
  "model_id": "eleven_flash_v2_5",
  "voice_settings": {
    "stability": 0.5,
    "similarity_boost": 0.75,
    "style": 0.0,
    "use_speaker_boost": true,
    "speed": 1.0
  }
}
```

**Request body:**

| Field | Type | Required | Notes |
|-------|------|----------|-------|
| `text` | string | Yes | Text to synthesize |
| `model_id` | string | No | Default: `eleven_multilingual_v2` |
| `voice_settings` | object | No | Stability, similarity, style, speed |
| `language_code` | string | No | ISO 639-1 code |
| `seed` | int | No | 0-4294967295 for deterministic output |

**Query params:**

| Param | Type | Default | Notes |
|-------|------|---------|-------|
| `output_format` | string | `mp3_44100_128` | Format: `codec_samplerate_bitrate` |
| `optimize_streaming_latency` | int | 0 | 0-4, higher = lower latency but less quality |

**Output format options:**
- `mp3_22050_32`, `mp3_44100_32`, `mp3_44100_64`, `mp3_44100_128`, `mp3_44100_192`
- `pcm_16000`, `pcm_22050`, `pcm_24000`, `pcm_44100`
- `ulaw_8000`, `alaw_8000`
- `opus_48000_32`, `opus_48000_64`, `opus_48000_128`

**Response:** `200` with `application/octet-stream` binary audio data.

**Error:** `422` validation error.

---

#### POST /v1/text-to-speech/{voice_id}/stream (streaming)

Same request body as non-streaming. Returns audio as a streaming binary response.

```
POST https://api.elevenlabs.io/v1/text-to-speech/VOICE_ID/stream?output_format=mp3_44100_128
xi-api-key: <API_KEY>
Content-Type: application/json
```

Response is chunked `application/octet-stream` -- audio chunks arrive as they are generated.

---

#### GET /v1/voices (list voices)

```
GET https://api.elevenlabs.io/v1/voices?page_size=100
xi-api-key: <API_KEY>
```

**Query params:**
- `search` (string): Search by name, description, labels
- `page_size` (int): Max 100, default 10
- `category`: `premade`, `cloned`, `generated`, `professional`
- `voice_type`: `personal`, `community`, `default`, `workspace`
- `sort`: `created_at_unix` or `name`
- `sort_direction`: `asc` or `desc`

**Response:** Array of voice objects with `voice_id`, `name`, `category`, `labels`, etc.

### Models

| Model ID | Name | Use Case |
|----------|------|----------|
| `eleven_multilingual_v2` | Multilingual v2 | Default, highest quality |
| `eleven_flash_v2_5` | Flash v2.5 | Low latency, good quality |
| `eleven_turbo_v2_5` | Turbo v2.5 | Fastest, acceptable quality |
| `eleven_monolingual_v1` | English v1 | English only, legacy |

**For low latency:** Use `eleven_flash_v2_5` + `optimize_streaming_latency=3` + streaming endpoint.

### Rate Limits

Rate limits depend on subscription tier. Tracked via response headers:
- `x-character-count`: Characters used in request
- `request-id`: Request tracking ID

### Elixir/Req Notes

- Non-streaming: `Req.post!` returns binary audio in response body -- write to file or send to channel
- Streaming: Use `Req.post!` with `into:` option to stream audio chunks
- Voice settings `stability` and `similarity_boost` are the most impactful -- experiment per voice
- For lowest time-to-first-audio: Flash model + streaming endpoint + `optimize_streaming_latency=3`
- Store `voice_id` in config/env var (`ELEVENLABS_VOICE_ID`)

---

## 10. Slack API

### Overview

Slack uses the Events API for receiving messages (webhook-based) and Web API for sending messages. Bot tokens with OAuth scopes.

### Base URL

**Web API:**
```
https://slack.com/api
```

### Authentication

```
Authorization: Bearer <SLACK_BOT_TOKEN>
Content-Type: application/json
```

Bot token starts with `xoxb-`. Created when the Slack app is installed to a workspace.

**Required scopes:**
- `chat:write` -- send messages
- `chat:write.public` -- send to any public channel (without joining)
- Specific event subscriptions require corresponding read scopes (e.g., `channels:history` for message events in public channels, `groups:history` for private channels)

### Key Endpoints

#### Events API: Receiving Messages

##### URL Verification (initial setup)

Slack sends a POST to your configured URL with a challenge:

```json
{
  "type": "url_verification",
  "challenge": "3eZbrw1aBm2rZgRNFdxV2595E9CY3gmdALWMmHkvFXO7tYXAYM8P",
  "token": "z26uFbvR1xHJEdHE1OQiO6t8"
}
```

**Your endpoint must respond with:**

```json
{
  "challenge": "3eZbrw1aBm2rZgRNFdxV2595E9CY3gmdALWMmHkvFXO7tYXAYM8P"
}
```

Or simply return the challenge string with `Content-Type: text/plain`.

---

##### Event Payload (message events)

```json
{
  "type": "event_callback",
  "token": "z26uFbvR1xHJEdHE1OQiO6t8",
  "team_id": "T123ABC456",
  "api_app_id": "A123ABC456",
  "event": {
    "type": "message",
    "subtype": null,
    "channel": "C123ABC456",
    "user": "U123ABC456",
    "text": "Hello assistant",
    "ts": "1708000000.000100",
    "event_ts": "1708000000.000100",
    "channel_type": "channel"
  },
  "event_id": "Ev123ABC456",
  "event_time": 1708000000,
  "authorizations": [
    {
      "enterprise_id": null,
      "team_id": "T123ABC456",
      "user_id": "U123BOT456",
      "is_bot": true
    }
  ]
}
```

---

##### Signature Verification (X-Slack-Signature)

Every request from Slack includes:
- `X-Slack-Signature`: HMAC-SHA256 signature
- `X-Slack-Request-Timestamp`: Unix timestamp

**Verification steps:**

1. Check `X-Slack-Request-Timestamp` is within 5 minutes (prevents replay attacks)
2. Construct the signature base string: `v0:TIMESTAMP:RAW_BODY`
3. Compute HMAC-SHA256 with your Signing Secret as key
4. Compare with `X-Slack-Signature` (which has format `v0=HASH`)

```elixir
# Pseudocode for verification
timestamp = get_req_header(conn, "x-slack-request-timestamp")
signature = get_req_header(conn, "x-slack-signature")
base_string = "v0:#{timestamp}:#{raw_body}"
expected = "v0=" <> :crypto.mac(:hmac, :sha256, signing_secret, base_string) |> Base.encode16(case: :lower)
Plug.Crypto.secure_compare(expected, signature)
```

---

#### POST /chat.postMessage (Web API)

```
POST https://slack.com/api/chat.postMessage
Authorization: Bearer xoxb-BOT-TOKEN
Content-Type: application/json
```

```json
{
  "channel": "C123ABC456",
  "text": "Hello! Here is your update.",
  "blocks": [
    {
      "type": "section",
      "text": {
        "type": "mrkdwn",
        "text": "Hello *world*! Here is your report."
      }
    }
  ]
}
```

**Required params:**
- `channel` (string): Channel ID, user ID (for DM), or channel name
- `text` (string): Fallback text (required even when using blocks)

**Optional params:**
- `blocks` (Block[]): Block Kit structured content
- `thread_ts` (string): Reply to thread
- `reply_broadcast` (boolean): Also post to channel
- `unfurl_links` (boolean): Unfurl URLs

**Response:**

```json
{
  "ok": true,
  "channel": "C123ABC456",
  "ts": "1708000001.000200",
  "message": {
    "text": "Hello! Here is your update.",
    "type": "message",
    "subtype": "bot_message",
    "ts": "1708000001.000200"
  }
}
```

### Rate Limits

- `chat.postMessage`: **1 message per second per channel** (burst allowance available)
- Workspace-level: Several hundred messages per minute
- Web API methods have tier-based rate limits (Tier 1-4)

### Elixir/Req Notes

- Signature verification must happen in a Plug before JSON parsing (needs raw body)
- Use `Plug.Conn.read_body/2` to capture raw body for HMAC verification
- Events API requires responding with `200 OK` within 3 seconds (acknowledge receipt, process async)
- Bot must be invited to private channels to receive events there
- Store Signing Secret and Bot Token in env vars (`SLACK_SIGNING_SECRET`, `SLACK_BOT_TOKEN`)

---

## Appendix: Common Google Auth Pattern (Elixir/goth)

All Google APIs (Chat, Drive, Gmail, Calendar) use the same service account + DWD authentication pattern.

**Token minting with goth:**

```elixir
# For bot operations (Google Chat)
{:ok, %{token: token}} = Goth.Token.for_scope("https://www.googleapis.com/auth/chat.bot")

# For user-impersonation via DWD (Drive, Gmail, Calendar)
{:ok, %{token: token}} = Goth.Token.for_scope(
  "https://www.googleapis.com/auth/drive https://www.googleapis.com/auth/gmail.modify https://www.googleapis.com/auth/calendar",
  %{sub: "user@yourdomain.com"}
)
```

**Req usage pattern:**

```elixir
Req.get!(
  "https://www.googleapis.com/drive/v3/files",
  params: [q: "name contains 'report'", fields: "files(id,name)"],
  auth: {:bearer, token}
)
```

**goth configuration (runtime.exs):**

```elixir
config :goth,
  json: System.fetch_env!("GOOGLE_SERVICE_ACCOUNT_JSON") |> Jason.decode!()
```

**DWD setup requirements:**
1. Service account created in GCP project
2. DWD enabled on service account
3. Client ID added to Workspace Admin Console > Security > API Controls > Domain Wide Delegation
4. Required scopes authorized for the client ID
5. Super-admin action required for step 4
