# Scoped Drive Access Architecture

## Executive Summary

This document specifies the architecture for scoped Google Drive access in Synaptic
Assistant. Users will be able to select which drives (personal "My Drive" and/or shared
drives) the AI agent can access. Drive selection is persisted per-user in the database
and threaded through the skill context at execution time, translating into Google Drive
API query constraints (`corpora`, `driveId`, `includeItemsFromAllDrives`, `supportsAllDrives`).

The design covers six areas:
1. Database schema for `connected_drives`
2. Drive client OAuth migration (access_token first-param pattern)
3. Drive discovery via Google's `drives.list` endpoint
4. Skill-level scoping logic that builds API query params from enabled drives
5. Settings UI LiveView component for drive management
6. Context threading from DB through skill execution

---

## 1. Database Schema: `connected_drives`

### Decision: Separate Table vs JSON Embedding

**Decision**: Use a dedicated `connected_drives` Ecto table.

**Rationale**: The user schema's `preferences` JSONB field is designed for
unstructured user preferences (display settings, etc.). Connected drives are a
structured, relational dataset that benefits from:
- Indexed lookups by user_id
- Unique constraints preventing duplicate entries
- Individual row-level toggles without full-JSON rewrite
- Foreign key integrity
- Query-time filtering (e.g., "all enabled drives for user X")

Embedding drive config in a JSON column would make queries awkward, prevent
indexing on `drive_id`, and conflate configuration data with preference data.

### Table Design

```
connected_drives
├── id          : binary_id (PK, autogenerated UUID)
├── user_id     : binary_id (FK → users.id, NOT NULL)
├── drive_id    : string (nullable — NULL for personal "My Drive")
├── drive_name  : string (NOT NULL — "My Drive" or shared drive name)
├── drive_type  : string (NOT NULL — "personal" or "shared")
├── enabled     : boolean (NOT NULL, default: true)
├── inserted_at : utc_datetime_usec
└── updated_at  : utc_datetime_usec
```

### Columns

| Column | Type | Nullable | Default | Notes |
|---|---|---|---|---|
| `id` | `:binary_id` | No | auto-UUID | Primary key |
| `user_id` | `:binary_id` | No | — | FK to `users.id`, `on_delete: :delete_all` |
| `drive_id` | `:string` | Yes | `nil` | Google Drive ID. `nil` for personal My Drive. Shared drives have a Google-assigned ID like `"0APQ..."` |
| `drive_name` | `:string` | No | — | Display name: `"My Drive"` or the shared drive's name from Google |
| `drive_type` | `:string` | No | — | Ecto enum: `"personal"` or `"shared"` |
| `enabled` | `:boolean` | No | `true` | Whether the agent can access this drive |
| `inserted_at` | `:utc_datetime_usec` | No | auto | Standard Ecto timestamp |
| `updated_at` | `:utc_datetime_usec` | No | auto | Standard Ecto timestamp |

### Indexes and Constraints

```elixir
# Migration
create table(:connected_drives, primary_key: false) do
  add :id, :binary_id, primary_key: true
  add :user_id, references(:users, type: :binary_id, on_delete: :delete_all), null: false
  add :drive_id, :string
  add :drive_name, :string, null: false
  add :drive_type, :string, null: false
  add :enabled, :boolean, null: false, default: true

  timestamps(type: :utc_datetime_usec)
end

# One personal drive per user; one row per shared drive per user
create unique_index(:connected_drives, [:user_id, :drive_id],
  name: :connected_drives_user_drive_unique,
  where: "drive_id IS NOT NULL"
)

create unique_index(:connected_drives, [:user_id],
  name: :connected_drives_user_personal_unique,
  where: "drive_id IS NULL"
)

create index(:connected_drives, [:user_id])
```

**Index rationale**:
- The partial unique index on `[:user_id, :drive_id] WHERE drive_id IS NOT NULL` prevents a user from adding the same shared drive twice.
- The partial unique index on `[:user_id] WHERE drive_id IS NULL` prevents a user from having more than one personal "My Drive" row.
- The plain `[:user_id]` index supports the primary query: "fetch all connected drives for user X."

### Ecto Schema

```elixir
# lib/assistant/schemas/connected_drive.ex

defmodule Assistant.Schemas.ConnectedDrive do
  @moduledoc """
  Represents a Google Drive (personal or shared) connected to a user's account.

  Each row maps a user to a specific drive they have authorized the agent to access.
  The `enabled` flag controls whether the drive is actively used for file operations.
  """
  use Ecto.Schema
  import Ecto.Changeset

  @primary_key {:id, :binary_id, autogenerate: true}
  @foreign_key_type :binary_id

  @drive_types ~w(personal shared)

  schema "connected_drives" do
    field :drive_id, :string
    field :drive_name, :string
    field :drive_type, :string
    field :enabled, :boolean, default: true

    belongs_to :user, Assistant.Schemas.User

    timestamps(type: :utc_datetime_usec)
  end

  @required_fields [:user_id, :drive_name, :drive_type]
  @optional_fields [:drive_id, :enabled]

  def changeset(drive, attrs) do
    drive
    |> cast(attrs, @required_fields ++ @optional_fields)
    |> validate_required(@required_fields)
    |> validate_inclusion(:drive_type, @drive_types)
    |> validate_personal_drive_id()
    |> unique_constraint([:user_id, :drive_id],
      name: :connected_drives_user_drive_unique,
      message: "this shared drive is already connected"
    )
    |> unique_constraint([:user_id],
      name: :connected_drives_user_personal_unique,
      message: "personal drive already connected"
    )
  end

  defp validate_personal_drive_id(changeset) do
    drive_type = get_field(changeset, :drive_type)
    drive_id = get_field(changeset, :drive_id)

    cond do
      drive_type == "personal" and not is_nil(drive_id) ->
        add_error(changeset, :drive_id, "must be nil for personal drives")

      drive_type == "shared" and is_nil(drive_id) ->
        add_error(changeset, :drive_id, "is required for shared drives")

      true ->
        changeset
    end
  end
end
```

### User Schema Association

Add to `Assistant.Schemas.User`:

```elixir
has_many :connected_drives, Assistant.Schemas.ConnectedDrive
```

---

## 2. Drive OAuth Migration: `access_token` First-Param Pattern

### Current State

The `Drive` module (`lib/assistant/integrations/google/drive.ex`) currently uses a
private `get_connection/0` function that calls `Auth.token()` to get a service account
token. This is the old pattern that Gmail and Calendar used before PR #11.

Per the CLAUDE.md pinned architecture, Gmail and Calendar have already migrated to
accept `access_token` as a first parameter so per-user OAuth tokens can be threaded
through. Drive has NOT yet been migrated.

### Migration Design

Every public function in `drive.ex` must be updated to accept `access_token` as its
first parameter:

| Current Signature | New Signature |
|---|---|
| `list_files(query, opts)` | `list_files(access_token, query, opts)` |
| `get_file(file_id)` | `get_file(access_token, file_id)` |
| `read_file(file_id, opts)` | `read_file(access_token, file_id, opts)` |
| `create_file(name, content, opts)` | `create_file(access_token, name, content, opts)` |
| `update_file_content(file_id, content, mime_type)` | `update_file_content(access_token, file_id, content, mime_type)` |
| `move_file(file_id, new_parent_id, remove_parents)` | `move_file(access_token, file_id, new_parent_id, remove_parents)` |
| `type_to_mime(type)` | Unchanged (no API call) |
| `google_workspace_type?(mime_type)` | Unchanged (no API call) |

### Implementation Changes in `drive.ex`

1. **Remove `get_connection/0`**. Replace all occurrences with a direct
   `Connection.new(access_token)` call at the top of each function.

2. **Add `access_token` as first param** to every public function that makes an API call.

3. **Update `@spec` types** accordingly:
   ```elixir
   @spec list_files(String.t(), String.t(), keyword()) :: {:ok, [map()]} | {:error, term()}
   def list_files(access_token, query, opts \\ []) do
     conn = Connection.new(access_token)
     # ... rest of function using conn directly
   end
   ```

4. **Internal calls**: `read_file` calls `get_file` internally. Since both now take
   `access_token`, thread it through:
   ```elixir
   def read_file(access_token, file_id, opts \\ []) do
     conn = Connection.new(access_token)
     with {:ok, metadata} <- get_file(access_token, file_id) do
       # ...
     end
   end
   ```

### Changes to Skill Files (5 files)

All five skill files in `lib/assistant/skills/files/` follow the same update pattern.

**Current pattern** (all 5 files):
```elixir
def execute(flags, context) do
  drive = Map.get(context.integrations, :drive, Drive)
  # ... calls like drive.list_files(query, opts)
end
```

**New pattern** (matches Gmail/Calendar nil-check pattern):
```elixir
def execute(flags, context) do
  case Map.get(context.integrations, :drive) do
    nil ->
      {:ok, %Result{status: :error, content: "Drive integration not configured."}}

    drive ->
      access_token = context.metadata[:google_token]

      case access_token do
        nil ->
          {:ok, %Result{status: :error, content: "Google authentication required. Please connect your Google account."}}

        token ->
          # ... calls like drive.list_files(token, query, opts)
      end
  end
end
```

**Key changes per file**:

| File | Change |
|---|---|
| `search.ex` | Replace `Map.get(context.integrations, :drive, Drive)` with nil-check. Add `access_token` to `drive.list_files(token, query, opts)`. |
| `read.ex` | Same nil-check. Add `access_token` to `drive.read_file(token, file_id, opts)` and `drive.get_file(token, file_id)`. |
| `write.ex` | Same nil-check. Add `access_token` to `drive.create_file(token, name, content, opts)`. |
| `update.ex` | Same nil-check. Add `access_token` to `drive.read_file(token, ...)`, `drive.update_file_content(token, ...)`. |
| `archive.ex` | Same nil-check. Add `access_token` to `drive.get_file(token, ...)`, `drive.list_files(token, ...)`, `drive.create_file(token, ...)`, `drive.move_file(token, ...)`. |

**Note on the nil-check migration**: The current skill files use `Map.get(context.integrations, :drive, Drive)` which falls back to the real Drive module. This contradicts the nil-check integration injection pattern established in Phase 4 and already used by Gmail/Calendar skills. This migration must fix this inconsistency.

---

## 3. Drive Discovery API

### Purpose

Users need to see which shared drives are available to them via Google's API so they
can choose which ones to connect. The `drives.list` endpoint returns all shared drives
accessible to the authenticated user.

### Google API: `drives.list`

**Endpoint**: `GET /drive/v3/drives`

**Elixir binding**: `GoogleApi.Drive.V3.Api.Drives.drive_drives_list/3`

```elixir
@spec drive_drives_list(Tesla.Env.client(), keyword(), keyword()) ::
  {:ok, GoogleApi.Drive.V3.Model.DriveList.t()} | {:error, any()}
```

**Relevant parameters**:
- `pageSize` (integer) — max results per page (default 10, max 100)
- `pageToken` (string) — pagination cursor
- `fields` (string) — field selector

**Response** (`GoogleApi.Drive.V3.Model.DriveList`):
```
%DriveList{
  kind: "drive#driveList",
  drives: [
    %Drive{id: "0APQ...", name: "Marketing Team", kind: "drive#drive", ...},
    %Drive{id: "0BRQ...", name: "Engineering", kind: "drive#drive", ...}
  ],
  nextPageToken: "..." | nil
}
```

**Fields to fetch**: `drives(id,name)` — we only need `id` and `name` for drive
selection. Capabilities and restrictions are not relevant for scoping.

### New Function in `drive.ex`

```elixir
@doc """
List shared drives accessible to the authenticated user.

Returns a flat list of shared drives with their IDs and names.
Paginates automatically to return all results.

## Returns

  - `{:ok, [%{id: String.t(), name: String.t()}]}` on success
  - `{:error, term()}` on failure
"""
@spec list_shared_drives(String.t()) :: {:ok, [map()]} | {:error, term()}
def list_shared_drives(access_token) do
  conn = Connection.new(access_token)
  list_shared_drives_page(conn, nil, [])
end

defp list_shared_drives_page(conn, page_token, acc) do
  opts =
    [pageSize: 100, fields: "drives(id,name),nextPageToken"]
    |> add_opt(:pageToken, page_token)

  case Drives.drive_drives_list(conn, opts) do
    {:ok, %{drives: drives, nextPageToken: next_token}} ->
      normalized =
        (drives || [])
        |> Enum.map(fn d -> %{id: d.id, name: d.name} end)

      all = acc ++ normalized

      if next_token do
        list_shared_drives_page(conn, next_token, all)
      else
        {:ok, all}
      end

    {:error, reason} ->
      Logger.warning("Drive list_shared_drives failed: #{inspect(reason)}")
      {:error, reason}
  end
end
```

**Pagination note**: Most users have fewer than 100 shared drives. The recursive
pagination handles edge cases while keeping the common path to a single API call.

---

## 4. Skill Scoping Logic

### How Drive Scoping Works in the Google API

The Google Drive `files.list` endpoint uses these parameters to control scope:

| Parameter | Type | Purpose |
|---|---|---|
| `corpora` | string | Which "bodies" to search: `user`, `drive`, `domain`, `allDrives` |
| `driveId` | string | Required when `corpora = "drive"`. Specifies the shared drive. |
| `includeItemsFromAllDrives` | boolean | Include items from shared drives in results |
| `supportsAllDrives` | boolean | Indicate the app supports shared drives |

### Scoping Strategy

The user's enabled drives list translates into API query constraints:

| Enabled Drives | `corpora` | `driveId` | `includeItemsFromAllDrives` | `supportsAllDrives` |
|---|---|---|---|---|
| Only My Drive | `user` | — | `false` | `true` |
| Only one shared drive | `drive` | `{drive_id}` | `true` | `true` |
| My Drive + shared drives | — (see below) | — | — | — |
| Multiple shared drives (no My Drive) | — (see below) | — | — | — |

**Multi-drive strategy**: The Google API does not support querying multiple specific
shared drives in a single call. When a user enables My Drive plus one or more shared
drives, we have two options:

**Option A — `allDrives` corpora + post-filter** (RECOMMENDED):
- Use `corpora: "allDrives"`, `includeItemsFromAllDrives: true`, `supportsAllDrives: true`
- This searches everything the user has access to
- Post-filter is NOT needed when the user enables ALL their drives
- When the user disables specific drives, we cannot post-filter by drive origin
  (the API does not return which drive a file belongs to in the standard fields)

**Option B — Sequential per-drive queries**:
- Issue one `files.list` call per enabled drive
- Merge and sort results client-side
- Preserves exact scoping but multiplies API calls

**Decision**: Use Option A (`allDrives`) when the user enables 2+ drives. Use
`corpora: "user"` for My-Drive-only. Use `corpora: "drive"` for single-shared-drive.

**Rationale**: Google themselves recommend `allDrives` as the corpora for
cross-drive queries. The penalty is that results may include files from drives the user
has disabled. For the initial implementation, this is acceptable — the primary use case
is "which drives should the agent look in" and most users will enable all or most of
their drives. If precise exclusion is needed later, Option B can be added behind a flag.

### New Module: `Drive.Scoping`

Create a focused helper module for building scoped query parameters.

**Location**: `lib/assistant/integrations/google/drive/scoping.ex`

```elixir
defmodule Assistant.Integrations.Google.Drive.Scoping do
  @moduledoc false

  @type drive_entry :: %{drive_id: String.t() | nil, drive_type: String.t()}

  @doc """
  Build Google Drive API query parameters from a list of enabled drives.

  Returns a keyword list to merge into `files.list` API options.

  ## Scoping rules

  - No enabled drives → error (no access)
  - Only personal drive → `corpora: "user"`
  - Single shared drive → `corpora: "drive", driveId: id`
  - Multiple drives (any mix) → `corpora: "allDrives"`
  """
  @spec build_query_params([drive_entry()]) ::
          {:ok, keyword()} | {:error, :no_drives_enabled}
  def build_query_params([]), do: {:error, :no_drives_enabled}

  def build_query_params(enabled_drives) do
    personal? = Enum.any?(enabled_drives, &(&1.drive_type == "personal"))
    shared = Enum.filter(enabled_drives, &(&1.drive_type == "shared"))

    params =
      case {personal?, shared} do
        {true, []} ->
          # My Drive only — default corpora is "user"
          [corpora: "user", supportsAllDrives: true]

        {false, [single]} ->
          # Single shared drive
          [
            corpora: "drive",
            driveId: single.drive_id,
            includeItemsFromAllDrives: true,
            supportsAllDrives: true
          ]

        _ ->
          # Multiple drives (My Drive + shared, or multiple shared)
          [
            corpora: "allDrives",
            includeItemsFromAllDrives: true,
            supportsAllDrives: true
          ]
      end

    {:ok, params}
  end
end
```

### Integration with `list_files/3`

The scoping params are merged into the options passed to `list_files/3`. The skill
handler (not the Drive client) is responsible for calling `Scoping.build_query_params/1`
and merging the result into the API call options:

```elixir
# In search.ex (conceptual flow)
enabled_drives = context.metadata[:enabled_drives]

case Scoping.build_query_params(enabled_drives) do
  {:ok, scope_params} ->
    opts = Keyword.merge([pageSize: limit], scope_params)
    drive.list_files(token, query, opts)

  {:error, :no_drives_enabled} ->
    {:ok, %Result{status: :error, content: "No drives are enabled. ..."}}
end
```

### Which Skills Need Scoping

| Skill | Needs scoping params? | Reason |
|---|---|---|
| `files.search` | **Yes** | Uses `list_files` — must scope search to enabled drives |
| `files.read` | No | Reads by file ID — Drive API handles access; if the file is in a disabled drive the user already has the ID |
| `files.write` | No | Creates by folder ID — the user specifies where to write |
| `files.update` | No | Updates by file ID — same as read |
| `files.archive` | Partial | Uses `list_files` to find/create Archive folder — scope this call. The `move_file` and `get_file` calls are by ID and don't need scoping. |

---

## 5. Settings UI Component

### Where It Fits

The existing `settings_live.ex` has an "Apps & Connections" section (`@section == "apps"`)
that shows connected apps from `@app_catalog`. Drive settings will be a sub-panel
within this section, shown when Google Workspace is connected.

### Component Design

**New LiveView component**: `AssistantWeb.Components.DriveSettings`

This is extracted as a separate function component (not a LiveComponent) to keep
`settings_live.ex` manageable (already ~1537 lines). The component receives assigns
and emits events handled by the parent.

### Data Flow

```
mount/handle_params
  ├── load_connected_drives(socket)    # Ecto query → assigns[:connected_drives]
  └── assigns[:available_drives] = []  # populated on-demand

User clicks "Refresh Drives"
  ├── handle_event("refresh_drives")
  │   ├── Drive.list_shared_drives(access_token)
  │   └── assigns[:available_drives] = results
  └── Renders: available drives with "Connect" / "Disconnect" buttons

User toggles drive enabled/disabled
  ├── handle_event("toggle_drive", %{"id" => drive_row_id, "enabled" => "true"/"false"})
  │   ├── ConnectedDrives.toggle(drive_row_id, enabled?)
  │   └── reload_connected_drives(socket)
  └── Renders: updated toggle state

User connects a new shared drive
  ├── handle_event("connect_drive", %{"drive_id" => google_drive_id, "name" => drive_name})
  │   ├── ConnectedDrives.connect(user_id, %{drive_id: ..., drive_name: ..., drive_type: "shared"})
  │   └── reload_connected_drives(socket)
  └── Renders: drive appears in connected list

User connects personal My Drive
  ├── handle_event("connect_personal_drive")
  │   ├── ConnectedDrives.connect(user_id, %{drive_id: nil, drive_name: "My Drive", drive_type: "personal"})
  │   └── reload_connected_drives(socket)
  └── Renders: My Drive appears in connected list
```

### UI Layout (within Apps section)

```
┌─────────────────────────────────────────────────────────────┐
│  Google Drive Access                                         │
│                                                              │
│  Connected Drives                              [Refresh]     │
│  ┌───────────────────────────────────────────────────────┐   │
│  │  My Drive (Personal)                    [enabled ◉]   │   │
│  │  Marketing Team (Shared)                [enabled ◉]   │   │
│  │  Engineering (Shared)                   [disabled ○]   │   │
│  └───────────────────────────────────────────────────────┘   │
│                                                              │
│  Available Shared Drives (after Refresh)                     │
│  ┌───────────────────────────────────────────────────────┐   │
│  │  Sales Team                              [Connect]     │   │
│  │  Design Assets                           [Connect]     │   │
│  └───────────────────────────────────────────────────────┘   │
│                                                              │
│  If My Drive is not connected:                               │
│  [Connect My Drive]                                          │
└─────────────────────────────────────────────────────────────┘
```

### New Context Module: `ConnectedDrives`

**Location**: `lib/assistant/connected_drives.ex`

This module provides the data access layer for `connected_drives`, following the
pattern of other context modules in the project.

```elixir
defmodule Assistant.ConnectedDrives do
  @moduledoc """
  Context module for managing user-connected Google Drives.
  """

  import Ecto.Query
  alias Assistant.Repo
  alias Assistant.Schemas.ConnectedDrive

  @doc "List all connected drives for a user."
  @spec list_for_user(String.t()) :: [ConnectedDrive.t()]
  def list_for_user(user_id) do
    ConnectedDrive
    |> where(user_id: ^user_id)
    |> order_by([d], [asc: d.drive_type, asc: d.drive_name])
    |> Repo.all()
  end

  @doc "List only enabled drives for a user (for skill execution)."
  @spec enabled_for_user(String.t()) :: [ConnectedDrive.t()]
  def enabled_for_user(user_id) do
    ConnectedDrive
    |> where(user_id: ^user_id, enabled: true)
    |> Repo.all()
  end

  @doc "Connect a drive for a user (upsert by user_id + drive_id)."
  @spec connect(String.t(), map()) :: {:ok, ConnectedDrive.t()} | {:error, Ecto.Changeset.t()}
  def connect(user_id, attrs) do
    %ConnectedDrive{}
    |> ConnectedDrive.changeset(Map.put(attrs, :user_id, user_id))
    |> Repo.insert(
      on_conflict: {:replace, [:drive_name, :enabled, :updated_at]},
      conflict_target: conflict_target(attrs)
    )
  end

  @doc "Toggle a connected drive's enabled state."
  @spec toggle(String.t(), boolean()) :: {:ok, ConnectedDrive.t()} | {:error, term()}
  def toggle(drive_row_id, enabled?) do
    case Repo.get(ConnectedDrive, drive_row_id) do
      nil -> {:error, :not_found}
      drive -> drive |> Ecto.Changeset.change(enabled: enabled?) |> Repo.update()
    end
  end

  @doc "Disconnect (delete) a drive."
  @spec disconnect(String.t()) :: {:ok, ConnectedDrive.t()} | {:error, term()}
  def disconnect(drive_row_id) do
    case Repo.get(ConnectedDrive, drive_row_id) do
      nil -> {:error, :not_found}
      drive -> Repo.delete(drive)
    end
  end

  defp conflict_target(%{drive_type: "personal"}), do: {:unsafe_fragment, "(user_id) WHERE drive_id IS NULL"}
  defp conflict_target(_), do: [:user_id, :drive_id]
end
```

### Settings LiveView Changes

Add to `settings_live.ex`:
- New assigns: `:connected_drives`, `:available_drives`, `:drives_loading`
- New event handlers: `"refresh_drives"`, `"toggle_drive"`, `"connect_drive"`, `"connect_personal_drive"`, `"disconnect_drive"`
- New `load_connected_drives/1` helper called in `load_section_data/2` for the `"apps"` section
- The Drive settings panel renders conditionally when the `"apps"` section is active

The Google access token for the current settings user is obtained from:
```elixir
# In the refresh_drives handler
settings_user = current_settings_user(socket)
# Fetch the user's Google OAuth token from the auth tokens table
# (This depends on the existing auth token infrastructure from PR #11)
```

---

## 6. Context Threading

### Flow: DB to API Call

```
                    ┌─────────────────┐
                    │   DB: connected  │
                    │     _drives      │
                    └────────┬────────┘
                             │ ConnectedDrives.enabled_for_user(user_id)
                             ▼
                    ┌─────────────────┐
                    │ [%ConnectedDrive │
                    │  {drive_id, ..} │
                    │  {nil, ..}]     │
                    └────────┬────────┘
                             │ Mapped to lightweight structs
                             ▼
                    ┌─────────────────┐
                    │ context.metadata │
                    │  [:enabled_      │
                    │   drives]        │
                    └────────┬────────┘
                             │ Skill handler reads at execution time
                             ▼
                    ┌─────────────────┐
                    │ Drive.Scoping   │
                    │ .build_query_   │
                    │  params(drives) │
                    └────────┬────────┘
                             │ Returns keyword list
                             ▼
                    ┌─────────────────┐
                    │ drive.list_files│
                    │ (token, q, opts)│
                    └─────────────────┘
```

### Changes to `build_skill_context`

Both context builders in the orchestrator need to inject enabled drives into
`context.metadata`:

**`loop_runner.ex` — `build_skill_context/1`**:
```elixir
defp build_skill_context(loop_state) do
  user_id = loop_state[:user_id] || "unknown"
  enabled_drives = load_enabled_drives(user_id)

  %Assistant.Skills.Context{
    conversation_id: loop_state[:conversation_id] || "unknown",
    execution_id: Ecto.UUID.generate(),
    user_id: user_id,
    channel: loop_state[:channel],
    integrations: Assistant.Integrations.Registry.default_integrations(),
    metadata: %{
      google_token: loop_state[:google_token],
      enabled_drives: enabled_drives
    }
  }
end

defp load_enabled_drives("unknown"), do: []
defp load_enabled_drives(user_id) do
  user_id
  |> Assistant.ConnectedDrives.enabled_for_user()
  |> Enum.map(fn d -> %{drive_id: d.drive_id, drive_type: d.drive_type} end)
end
```

**`sub_agent.ex` — `build_skill_context/2`**:
```elixir
defp build_skill_context(dispatch_params, engine_state) do
  root_conversation_id =
    engine_state[:parent_conversation_id] || engine_state[:conversation_id] || "unknown"

  user_id = engine_state[:user_id] || "unknown"
  enabled_drives = load_enabled_drives(user_id)

  %Context{
    conversation_id: engine_state[:conversation_id] || "unknown",
    execution_id: Ecto.UUID.generate(),
    user_id: user_id,
    channel: engine_state[:channel],
    integrations: Assistant.Integrations.Registry.default_integrations(),
    metadata: %{
      agent_id: dispatch_params.agent_id,
      root_conversation_id: root_conversation_id,
      agent_type: engine_state[:agent_type] || :orchestrator,
      google_token: engine_state[:google_token],
      enabled_drives: enabled_drives
    }
  }
end
```

### Performance Consideration

`ConnectedDrives.enabled_for_user/1` runs a simple indexed query on `user_id` +
`enabled = true`. This returns at most a handful of rows (typical user has 1-5 drives).
The query is fast enough to run synchronously during context construction. No caching
is needed for the initial implementation.

If profiling later shows this as a bottleneck (e.g., high-throughput multi-agent
scenarios), the drives list could be cached in the engine_state/loop_state and
refreshed on settings changes via PubSub.

### Type Update for `Context.t()`

Add to `%Context{}` type spec:
```elixir
@type metadata :: %{
  optional(:google_token) => String.t(),
  optional(:enabled_drives) => [%{drive_id: String.t() | nil, drive_type: String.t()}],
  optional(:agent_id) => String.t(),
  optional(:root_conversation_id) => String.t(),
  optional(:agent_type) => atom()
}
```

No structural change to the Context struct itself — `metadata` is already `map()`.

---

## ADR: Key Architectural Decisions

### ADR-1: Separate Table for Connected Drives

**Status**: Accepted

**Decision**: Use a dedicated `connected_drives` table rather than embedding drive
config in the `users.preferences` JSONB column.

**Rationale**: Structured data with unique constraints, indexed lookups, and
row-level operations. JSONB is the wrong abstraction for a relational dataset.

### ADR-2: `allDrives` Corpora for Multi-Drive Scoping

**Status**: Accepted

**Decision**: Use `corpora: "allDrives"` when 2+ drives are enabled, rather than
issuing per-drive queries.

**Rationale**: Fewer API calls, simpler code, Google-recommended approach. Tradeoff
is that results may include files from non-enabled drives. Acceptable for MVP; can
add per-drive querying behind a flag later if exact exclusion is needed.

### ADR-3: Scoping Applied at Skill Level, Not Client Level

**Status**: Accepted

**Decision**: The `Drive.Scoping` module is called by skill handlers (e.g., `search.ex`),
not by the `Drive` client itself.

**Rationale**: The Drive client (`drive.ex`) is a thin API wrapper. It should not
know about user preferences or connected drives. Scoping is a business concern that
belongs at the skill layer. This keeps the client reusable and testable without
context dependencies.

### ADR-4: Fix Drive Skill Integration Injection Pattern

**Status**: Accepted

**Decision**: Migrate all 5 file skill files from `Map.get(context.integrations, :drive, Drive)` (fallback to real module) to the nil-check pattern without fallback, matching Gmail/Calendar.

**Rationale**: The fallback-to-real-module pattern was explicitly removed in Phase 4.
The Drive skills were never updated. This is a correctness fix, not a refactor.

---

## Implementation Roadmap

### Phase 1: Foundation (No UI, Backend Only)

**Milestone**: Drive client migrated, DB schema ready, scoping logic implemented.

1. **Migration**: Create `connected_drives` table migration
2. **Schema**: Create `Assistant.Schemas.ConnectedDrive` + user association
3. **Context module**: Create `Assistant.ConnectedDrives` with CRUD functions
4. **Drive client**: Add `access_token` as first param to all public functions in `drive.ex`
5. **Drive discovery**: Add `list_shared_drives/1` to `drive.ex`
6. **Scoping module**: Create `Assistant.Integrations.Google.Drive.Scoping`
7. **Skill files**: Update all 5 file skills (nil-check + token threading + scoping in search/archive)
8. **Context builders**: Update `loop_runner.ex` and `sub_agent.ex` to inject `enabled_drives`

**Dependencies**: Steps 1-3 can run in parallel with steps 4-6. Step 7 depends on 4+6. Step 8 depends on 3.

### Phase 2: Settings UI

**Milestone**: Users can manage drive connections from the Settings page.

1. **Component**: Create `DriveSettings` function component
2. **Settings LiveView**: Add drive-related assigns, event handlers, section rendering
3. **Token access**: Wire up Google OAuth token retrieval for drive discovery calls

**Dependencies**: Depends on Phase 1 completion.

### Phase 3: Testing

**Milestone**: Full test coverage for new functionality.

1. **Schema tests**: ConnectedDrive changeset validations, unique constraints
2. **Context module tests**: ConnectedDrives CRUD operations
3. **Scoping tests**: All combinations of drive configurations → API params
4. **Skill integration tests**: Verify nil-check, token threading, scoped queries
5. **LiveView tests**: Drive settings panel interactions

### Development Order

```
Phase 1 (parallel tracks):
  Track A: Migration + Schema + Context module (steps 1-3)
  Track B: Drive client migration + discovery + Scoping (steps 4-6)
  Then: Skill files (7) — depends on both tracks
  Then: Context builders (8) — depends on Track A

Phase 2: Settings UI (sequential, depends on Phase 1)

Phase 3: Testing (can start partially during Phase 1/2)
```

---

## Risk Assessment

| Risk | Severity | Likelihood | Mitigation |
|---|---|---|---|
| `allDrives` corpora returns files from disabled drives | Low | Medium | Acceptable for MVP. Add per-drive querying later if users report confusion. |
| Drive skill nil-check migration breaks existing tests | Medium | Medium | Existing tests use mock Drive module in integrations map; update test fixtures to ensure `:drive` key is present. |
| `google_token` not yet in metadata for all code paths | Medium | Low | The CLAUDE.md claims PR #11 added `context.google_token` but current code shows no such field. Verify by checking `engine_state[:google_token]` is populated. If not, this is a dependency that must be resolved first. |
| Shared drive API requires `drive.readonly` scope | Low | Low | Already included in `Auth.scopes/0` (`drive.readonly` and `drive.file`). |
| Settings page already ~1537 lines | Low | High | Extract Drive settings as a function component in a separate module. |

---

## File Inventory

### New Files
| File | Purpose |
|---|---|
| `priv/repo/migrations/YYYYMMDD_create_connected_drives.exs` | Database migration |
| `lib/assistant/schemas/connected_drive.ex` | Ecto schema |
| `lib/assistant/connected_drives.ex` | Context module (CRUD) |
| `lib/assistant/integrations/google/drive/scoping.ex` | Query param builder |
| `lib/assistant_web/components/drive_settings.ex` | Settings UI component |

### Modified Files
| File | Changes |
|---|---|
| `lib/assistant/integrations/google/drive.ex` | Add `access_token` first param; add `list_shared_drives/1`; remove `get_connection/0` |
| `lib/assistant/skills/files/search.ex` | Nil-check pattern + token + scoping |
| `lib/assistant/skills/files/read.ex` | Nil-check pattern + token |
| `lib/assistant/skills/files/write.ex` | Nil-check pattern + token |
| `lib/assistant/skills/files/update.ex` | Nil-check pattern + token |
| `lib/assistant/skills/files/archive.ex` | Nil-check pattern + token + partial scoping |
| `lib/assistant/schemas/user.ex` | Add `has_many :connected_drives` |
| `lib/assistant/orchestrator/loop_runner.ex` | Inject `enabled_drives` into context metadata |
| `lib/assistant/orchestrator/sub_agent.ex` | Inject `enabled_drives` into context metadata |
| `lib/assistant_web/live/settings_live.ex` | Drive settings section + event handlers |
| `lib/assistant/skills/context.ex` | Update `@type metadata` docs (optional) |
